//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   16/May/2011  12:36:13 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203\PRG\APP_V2.35\source\Process.c      /
//    Command line    =  D:\Design\DS203\PRG\APP_V2.35\source\Process.c -lA  /
//                       D:\Design\DS203\PRG\APP_V2.35\IAR_V4_Prpject\List\  /
//                       -o D:\Design\DS203\PRG\APP_V2.35\IAR_V4_Prpject\Obj /
//                       \ -s9 --debug --cpu_mode thumb --endian little      /
//                       --cpu cortex-M3 --stack_align 4 --fpu None          /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8f.h" -I                /
//                       D:\Design\DS203\PRG\APP_V2.35\IAR_V4_Prpject\..\..\ /
//                       FWLib\inc\ -I D:\Design\DS203\PRG\APP_V2.35\IAR_V4_ /
//                       Prpject\..\..\USBLib\inc\ -I                        /
//                       D:\Design\DS203\PRG\APP_V2.35\IAR_V4_Prpject\..\inc /
//                       lude\ -I "C:\Program Files\IAR Systems\Embedded     /
//                       Workbench 4.0 Evaluation\arm\INC\"                  /
//                       --inline_threshold=16                               /
//    List file       =  D:\Design\DS203\PRG\APP_V2.35\IAR_V4_Prpject\List\P /
//                       rocess.s79                                          /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Process

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??div32_t

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable10 EQU 0
??DataTable11 EQU 0
??DataTable2 EQU 0
??DataTable8 EQU 0
??DataTable9 EQU 0
        MULTWEAK ??Delayms??rT
        MULTWEAK ??Draw_Window??rT
        MULTWEAK ??Get_Ref_Wave??rT
        MULTWEAK ??Int_sqrt??rT
        MULTWEAK ??__Clear_Screen??rT
        MULTWEAK ??__Get??rT
        MULTWEAK ??__Read_FIFO??rT
        MULTWEAK ??__Set??rT
        MULTWEAK ??rT??div32_t
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC A_Max
        PUBLIC A_Min
        PUBLIC A_Rms
        PUBLIC A_Tab
        PUBLIC A_Vdc
        PUBLIC A_Vpp
        PUBLIC App_init
        FUNCTION App_init,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC B_Max
        PUBLIC B_Min
        PUBLIC B_Rms
        PUBLIC B_Vdc
        PUBLIC B_Vpp
        PUBLIC CH_D_Data
        FUNCTION CH_D_Data,0203H
        LOCFRAME CSTACK, 44, STACK
        PUBLIC Ch
        PUBLIC D_Tab
        PUBLIC DataBuf
        PUBLIC Full
        PUBLIC G_Attr
        PUBLIC Interlace
        PUBLIC JumpCnt
        PUBLIC Ka1
        PUBLIC Ka2
        PUBLIC Ka3
        PUBLIC Kab
        PUBLIC Kb1
        PUBLIC Kb2
        PUBLIC Kb3
        PUBLIC Process
        FUNCTION Process,0203H
        LOCFRAME CSTACK, 64, STACK
        PUBLIC SAW_DATA
        PUBLIC SIN_DATA
        PUBLIC Synchro
        FUNCTION Synchro,0203H
        LOCFRAME CSTACK, 36, STACK
        PUBLIC TRG_DATA
        PUBLIC T_Attr
        PUBLIC Tmp
        PUBLIC TrackBuff
        PUBLIC Update_Base
        FUNCTION Update_Base,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Output
        FUNCTION Update_Output,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Range
        FUNCTION Update_Range,0203H
        LOCFRAME CSTACK, 28, STACK
        PUBLIC Update_Trig
        FUNCTION Update_Trig,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC V
        PUBLIC View_init
        FUNCTION View_init,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Wait
        PUBLIC X_Attr
        PUBLIC Y_Attr
        PUBLIC a_Avg
        PUBLIC a_Ssq
        PUBLIC a_max
        PUBLIC a_min
        PUBLIC b_Avg
        PUBLIC b_Ssq
        PUBLIC b_max
        PUBLIC b_min
        PUBLIC n
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
Draw_Window         SYMBOL "Draw_Window"
Get_Ref_Wave        SYMBOL "Get_Ref_Wave"
Int_sqrt            SYMBOL "Int_sqrt"
__Clear_Screen      SYMBOL "__Clear_Screen"
__Get               SYMBOL "__Get"
__Read_FIFO         SYMBOL "__Read_FIFO"
__Set               SYMBOL "__Set"
??Delayms??rT       SYMBOL "??rT", Delayms
??Draw_Window??rT   SYMBOL "??rT", Draw_Window
??Get_Ref_Wave??rT  SYMBOL "??rT", Get_Ref_Wave
??Int_sqrt??rT      SYMBOL "??rT", Int_sqrt
??__Clear_Screen??rT SYMBOL "??rT", __Clear_Screen
??__Get??rT         SYMBOL "??rT", __Get
??__Read_FIFO??rT   SYMBOL "??rT", __Read_FIFO
??__Set??rT         SYMBOL "??rT", __Set

        EXTERN Current
        EXTERN Delayms
        FUNCTION Delayms,0202H
        EXTERN Draw_Window
        FUNCTION Draw_Window,0202H
        EXTERN FileBuff
        EXTERN Get_Ref_Wave
        FUNCTION Get_Ref_Wave,0202H
        EXTERN Int_sqrt
        FUNCTION Int_sqrt,0202H
        EXTERN Meter
        EXTERN PD_Cnt
        EXTERN Title
        EXTERN Update
        EXTERN V_Trigg
        EXTERN Wait_Cnt
        EXTERN __Clear_Screen
        FUNCTION __Clear_Screen,0202H
        EXTERN __Get
        FUNCTION __Get,0202H
        EXTERN __Read_FIFO
        FUNCTION __Read_FIFO,0202H
        EXTERN __Set
        FUNCTION __Set,0202H

// D:\Design\DS203\PRG\APP_V2.35\source\Process.c
//    1 /******************** (C) COPYRIGHT 2009 e-Design Co.,Ltd. *********************
//    2  File Name : Process.c       
//    3  Version   : DS203_APP Ver 2.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Interrupt.h"
//    6 #include "Function.h"
//    7 #include "Process.h"
//    8 #include "Draw.h"
//    9 #include "Menu.h"
//   10 #include "BIOS.h"
//   11 #include "File.h"
//   12 
//   13 s8  Kab;                                   // 模拟通道零点平衡校正系数
//   14 u32 a_Avg, b_Avg, a_Ssq, b_Ssq;            // 统计用中间变量
//   15 u8  a_max, b_max, a_min, b_min;            // 统计用中间变量
//   16 s16 A_Vdc, A_Vpp, A_Max, A_Min, A_Rms;     // 计量结果

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   17 s16 B_Vdc, B_Vpp, B_Max, B_Min, B_Rms;     
B_Rms:
        DS8 2
//   18 u8  Ch[4], V[8];
//   19 s32 Tmp;
//   20 
//   21 u16  JumpCnt, n;
//   22 u8   Full=1, Interlace;
//   23 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   24 uc16 Wait[27]= {1000, 500, 200, 100, 50, 20, 10, 5, 2, 2,   
Wait:
        DATA
        DC16 1000, 500, 200, 100, 50, 20, 10, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC16 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC8 0, 0
//   25                 2,      2,   2,   2,  2,  2,  2, 2, 2, 2,    
//   26                 2,      2,   2,   2,  2,  2,  2 };
//   27                      

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   28 Y_attr *Y_Attr; 
Y_Attr:
        DS8 4
//   29 X_attr *X_Attr; 
//   30 G_attr *G_Attr; 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   31 T_attr *T_Attr; 
T_Attr:
        DS8 4
//   32 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   33 u32  DataBuf[4096];
DataBuf:
        DS8 16384

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   34 u8  TrackBuff  [X_SIZE * 4];         // 曲线轨迹缓存：i+0,i+1,i+2,i+3,分别存放1～4号轨迹数据
TrackBuff:
        DS8 1200

        RSEG DATA_I:DATA:SORT:NOROOT(2)
V:
        DS8 8
        REQUIRE `?<Initializer for V>`
Ch:
        DS8 4
        REQUIRE `?<Initializer for Ch>`
a_max:
        DS8 1
        REQUIRE `?<Initializer for a_max>`
b_max:
        DS8 1
        REQUIRE `?<Initializer for b_max>`
a_min:
        DS8 1
        REQUIRE `?<Initializer for a_min>`
b_min:
        DS8 1
        REQUIRE `?<Initializer for b_min>`
Interlace:
        DS8 1
        REQUIRE `?<Initializer for Interlace>`
        DS8 1
A_Vdc:
        DS8 2
        REQUIRE `?<Initializer for A_Vdc>`
A_Vpp:
        DS8 2
        REQUIRE `?<Initializer for A_Vpp>`
A_Max:
        DS8 2
        REQUIRE `?<Initializer for A_Max>`
A_Min:
        DS8 2
        REQUIRE `?<Initializer for A_Min>`
A_Rms:
        DS8 2
        REQUIRE `?<Initializer for A_Rms>`
B_Vdc:
        DS8 2
        REQUIRE `?<Initializer for B_Vdc>`
B_Vpp:
        DS8 2
        REQUIRE `?<Initializer for B_Vpp>`
B_Max:
        DS8 2
        REQUIRE `?<Initializer for B_Max>`
B_Min:
        DS8 2
        REQUIRE `?<Initializer for B_Min>`
JumpCnt:
        DS8 2
        REQUIRE `?<Initializer for JumpCnt>`
n:
        DS8 2
        REQUIRE `?<Initializer for n>`
//   35 
//   36 s8  Ka1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // A通道零点误差校正系数
//   37 s8  Kb1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // B通道零点误差校正系数
//   38 u16 Ka2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // A通道增益误差校正系数
Ka2:
        DS8 20
        REQUIRE `?<Initializer for Ka2>`
//   39 u16 Kb2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // B通道增益误差校正系数
Kb2:
        DS8 20
        REQUIRE `?<Initializer for Kb2>`
Kab:
        DS8 1
        REQUIRE `?<Initializer for Kab>`
        DS8 3
Ka1:
        DS8 12
        REQUIRE `?<Initializer for Ka1>`
Kb1:
        DS8 12
        REQUIRE `?<Initializer for Kb1>`
a_Avg:
        DS8 4
        REQUIRE `?<Initializer for a_Avg>`
b_Avg:
        DS8 4
        REQUIRE `?<Initializer for b_Avg>`
a_Ssq:
        DS8 4
        REQUIRE `?<Initializer for a_Ssq>`
b_Ssq:
        DS8 4
        REQUIRE `?<Initializer for b_Ssq>`
Tmp:
        DS8 4
        REQUIRE `?<Initializer for Tmp>`
X_Attr:
        DS8 4
        REQUIRE `?<Initializer for X_Attr>`

        RSEG DATA_I:DATA:SORT:NOROOT(0)
Full:
        DS8 1
        REQUIRE `?<Initializer for Full>`

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   40 u16 Ka3 = 256, Kb3 = 256;                                                // A B通道位移误差校正系数
Ka3:
        DS8 2
        REQUIRE `?<Initializer for Ka3>`
Kb3:
        DS8 2
        REQUIRE `?<Initializer for Kb3>`
G_Attr:
        DS8 4
        REQUIRE `?<Initializer for G_Attr>`
//   41 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   42 D_tab D_Tab[20] ={  // 脉冲波形输出驱动表, 基于72MHz主频
D_Tab:
        DS8 280
        REQUIRE `?<Initializer for D_Tab>`
//   43 //    STR      PSC     ARR       DUTY% 
//   44   {" 10Hz ",  180-1,  40000-1,     50},
//   45   {" 20Hz ",  180-1,  20000-1,     50},
//   46   {" 50Hz ",  180-1,   8000-1,     50},
//   47   {"!100Hz!", 180-1,   4000-1,     50},
//   48   {"!200Hz!", 180-1,   2000-1,     50},
//   49   {"!500Hz!", 180-1,    800-1,     50},
//   50   {" 1KHz ",  180-1,    400-1,     50},
//   51   {" 2KHz ",  180-1,    200-1,     50},
//   52   {" 5KHz ",   18-1,    800-1,     50},
//   53   {"!10KHz!",  18-1,    400-1,     50},
//   54   {"!20KHz!",  18-1,    200-1,     50},
//   55   {"!50KHz!",   1-1,   1440-1,     50},
//   56   {"100KHz",    1-1,    720-1,     50},
//   57   {"200KHz",    1-1,    360-1,     50},
//   58   {"500KHz",    1-1,    144-1,     50},
//   59   {" 1MHz ",    1-1,     72-1,     50},
//   60   {" 2MHz ",    1-1,     36-1,     50},
//   61   {" 4MHz ",    1-1,     18-1,     50},
//   62   {" 6MHz ",    1-1,     12-1,     50},
//   63   {" 8MHz ",    1-1,      9-1,     50}};
//   64 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   65 A_tab A_Tab[11] ={ // 模拟波形输出驱动表, 基于72MHz主频, 每周期36点合成
A_Tab:
        DS8 132
        REQUIRE `?<Initializer for A_Tab>`
//   66 //    STR     PSC     ARR 
//   67   {" 10Hz ",  20-1,  10000-1},
//   68   {" 20Hz ",  20-1,   5000-1},
//   69   {" 50Hz ",  20-1,   2000-1},
//   70   {"!100Hz!", 20-1,   1000-1},
//   71   {"!200Hz!", 20-1,    500-1},
//   72   {"!500Hz!", 20-1,    200-1},
//   73   {" 1KHz ",  20-1,    100-1},
//   74   {" 2KHz ",  20-1,     50-1},
//   75   {" 5KHz ",  20-1,     20-1},
//   76   {"!10KHz!", 20-1,     10-1},
//   77   {"!20KHz!", 20-1,      5-1}};
//   78 
//   79 u16 SIN_DATA[36] =  // Sine wave data                                                                                                 //         
SIN_DATA:
        DS8 72
        REQUIRE `?<Initializer for SIN_DATA>`
//   80   {0x000,0x027,0x08E,0x130,0x209,0x311,0x441,0x58F,0x6F0,    // 90
//   81    0x85A,0x9C0,0xB19,0xC59,0xD76,0xE68,0xF26,0xFAB,0xFF3,    // 180
//   82    0xFFF,0xFD7,0xF70,0xECE,0xDF5,0xCED,0xBBD,0xA6F,0x90E,    // 270
//   83    0x7A4,0x63E,0x4E5,0x3A5,0x288,0x196,0x0D8,0x053,0x00B,};  // 360   
//   84 
//   85 u16 TRG_DATA[36] =  // triangle wave data
TRG_DATA:
        DS8 72
        REQUIRE `?<Initializer for TRG_DATA>`
//   86   {0x000,0x0E3,0x1C6,0x2AA,0x38D,0x471,0x554,0x638,0x71B,    // 90
//   87    0x7FF,0x8E2,0x9C6,0xAA9,0xB8D,0xC70,0xD54,0xE37,0xF1B,    // 180
//   88    0xFFE,0xF1B,0xE37,0xD54,0xC70,0xB8D,0xAA9,0x9C6,0x8E2,    // 270
//   89    0x7FF,0x71B,0x638,0x554,0x471,0x38D,0x2AA,0x1C6,0x0E3};   // 360			
//   90          
//   91 u16 SAW_DATA[36] =  // Sawtooth wave data                                                                                             //         
SAW_DATA:
        DS8 72
        REQUIRE `?<Initializer for SAW_DATA>`
//   92   {0x000,0x075,0x0EA,0x15F,0x1D4,0x249,0x2BE,0x333,0x3A8,    // 90
//   93    0x41D,0x492,0x507,0x57C,0x5F1,0x666,0x6DB,0x750,0x7C5,    // 180
//   94    0x83A,0x8AF,0x924,0x999,0xA0E,0xA83,0xAF8,0xB6D,0xBE2,    // 270
//   95    0xC57,0xCCC,0xD41,0xDB6,0xE2B,0xEA0,0xF15,0xF8A,0xFFF};   // 360    
//   96 
//   97 
//   98 /*******************************************************************************
//   99  App_init: 显示窗口波形数据初始化
//  100 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function App_init
        THUMB
//  101 void App_init(void)
//  102 { 
App_init:
        PUSH     {R4,R5,R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  103   u16 i, j;
//  104   __Set(ADC_CTRL, EN );       
        MOVS     R1,#+1
//  105   __Set(STANDBY, DN);          // 退出省电状态
//  106   __Clear_Screen(BLACK);       // 清屏幕
//  107   Delayms(20); 
//  108   __Set(FIFO_CLR, W_PTR); 
//  109   for(i=0; i<13; i++) for(j=0; j<4; j++) Title[i][j].Flag |= UPDAT;
        LDR.N    R4,??DataTable3  ;; Title
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R0,#+20
        _BLF     __Set,??__Set??rT
        MOVS     R0,#+0
        _BLF     __Clear_Screen,??__Clear_Screen??rT
        MOVS     R0,#+20
        _BLF     Delayms,??Delayms??rT
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOVS     R7,#+80
??App_init_0:
        MOVS     R3,#+0
??App_init_1:
        MOVS     R5,R2
        MOVS     R0,#+20
        MLA      R5,R5,R7,R4
        MLA      R0,R3,R0,R5
        ADDS     R3,R3,#+1
        UXTH     R3,R3
        LDRB     R5,[R0, #+18]
        ORRS     R5,R5,#0x2
        STRB     R5,[R0, #+18]
        CMP      R3,#+4
        BCC.N    ??App_init_1
        ADDS     R2,R2,#+1
        UXTH     R2,R2
        CMP      R2,#+13
        BCC.N    ??App_init_0
//  110   for(i=0; i<9; i++)                     Meter[i].Flag    |= UPDAT;
        LDR.N    R5,??App_init_2  ;; Meter
        MOVS     R0,#+0
??App_init_3:
        MOVS     R2,R0
        MOVS     R3,#+12
        ADDS     R0,R0,#+1
        MLA      R2,R2,R3,R5
        UXTH     R0,R0
        LDRB     R3,[R2, #+11]
        ORRS     R3,R3,#0x2
        STRB     R3,[R2, #+11]
        CMP      R0,#+9
        BCC.N    ??App_init_3
//  111   if(Current != FILE) {
        LDR.N    R0,??App_init_2+0x4  ;; Current
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BEQ.N    ??App_init_4
//  112     Title[FILE][0].Flag &= !UPDAT;
        ADDW     R0,R4,#+738
//  113     Title[FILE][1].Flag &= !UPDAT;
//  114     Title[FILE][3].Flag &= !UPDAT;
        STRB     R1,[R4, #+798]
        STRB     R1,[R0, #+0]
        STRB     R1,[R0, #+20]
//  115   }  
//  116   PD_Cnt = 600;
??App_init_4:
        LDR.N    R0,??App_init_2+0x8  ;; PD_Cnt
        MOVS     R1,#+600
        STRH     R1,[R0, #+0]
//  117   Update = 1;                  // 返回后恢复原来的档位设置
        LDR.N    R0,??App_init_2+0xC  ;; Update
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  118 }
        POP      {R4,R5,R7,PC}
        DATA
??App_init_2:
        DC32     Meter
        DC32     Current
        DC32     PD_Cnt
        DC32     Update
        CFI EndBlock cfiBlock0
//  119 /*******************************************************************************
//  120  View_init: 显示窗口波形数据初始化
//  121 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function View_init
        THUMB
//  122 void View_init(void)
//  123 { 
View_init:
        PUSH     {R4,R6-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  124   u16 i, j = 0, k = 0;
        MOVS     R6,#+0
//  125   for(i = 0; i < X_SIZE * 4; i += 4){
        MOVS     R4,#+0
        MOV      R8,R6
        B.N      ??View_init_0
//  126     TrackBuff[i] = 160;
??View_init_1:
        LDR.N    R0,??DataTable1  ;; TrackBuff
        ADDS     R7,R0,R4
        MOVS     R0,#+160
        STRB     R0,[R7, #+0]
//  127     TrackBuff[i+1] = Get_Ref_Wave(i/4);
        LSRS     R0,R4,#+2
        UXTH     R0,R0
        _BLF     Get_Ref_Wave,??Get_Ref_Wave??rT
        STRB     R0,[R7, #+1]
//  128     if((i%160)==0) j = 1 - j;
        MOVS     R0,R4
        MOVS     R1,#+160
        _BLF     ??div32_t,??rT??div32_t
        CBNZ     R0,??View_init_2
        MOVS     R0,#+1
        MOV      R1,R8
        SUBS     R0,R0,R1
        UXTH     R0,R0
        MOV      R8,R0
//  129     TrackBuff[i+2] = 60 + (j * 17);
??View_init_2:
        MOVS     R0,#+17
        MUL      R0,R8,R0
        ADDS     R0,R0,#+60
        STRB     R0,[R7, #+2]
//  130     if((i%64)==0) k = 1 - k;
        LSRS     R0,R4,#+6
        UXTH     R0,R0
        SUBS     R0,R4,R0, LSL #+6
        ITTT    EQ 
        MOVEQ    R0,#+1
        SUBEQ    R6,R0,R6
        UXTHEQ   R6,R6
//  131     TrackBuff[i+3] = 20 + (k * 17);
        MOVS     R0,#+17
//  132   }
        ADDS     R4,R4,#+4
        MULS     R0,R6,R0
        ADDS     R0,R0,#+20
        STRB     R0,[R7, #+3]
        UXTH     R4,R4
??View_init_0:
        MOVS     R1,#+1200
        CMP      R4,R1
        BCC.N    ??View_init_1
//  133 }
        POP      {R4,R6-R8,PC}
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     TrackBuff
//  134 /*******************************************************************************
//  135  Update_Range: 
//  136 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Update_Range
        THUMB
//  137 void Update_Range(void) 
//  138 {
Update_Range:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  139   Interlace = 0;
        LDR.N    R4,??DataTable7  ;; V
//  140   __Set(ADC_MODE, SEPARATE);                        // Set Separate mode
//  141   __Set(CH_A_COUPLE, Title[TRACK1][COUPLE].Value);
        LDR.N    R5,??DataTable3  ;; Title
//  142   __Set(CH_A_RANGE,  Title[TRACK1][RANGE].Value);
//  143   __Set(CH_A_OFFSET, (Ka3 * Title[TRACK1][POSI].Value)/256);
        LDR.N    R7,??Update_Range_0  ;; Ka3
        MOVS     R0,#+0
        MOVS     R6,R5
        ADDS     R6,R6,#+16
        STRB     R0,[R4, #+16]
        MOVS     R1,#+0
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+20]
        MOVS     R0,#+9
//  144   if(_1_source == HIDE){
        ADDW     R8,R5,#+336
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+40]
        MOVS     R0,#+10
        _BLF     __Set,??__Set??rT
        LDRH     R0,[R7, #+0]
        LDRSH    R1,[R6, #+60]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+0
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R6, #+0]
        CBNZ     R0,??Update_Range_1
//  145     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_1
//  146       __Set(CH_A_RANGE, G_Attr[0].Yp_Max+1);        // A通道合并到B通道 
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+10
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  147       __Set(ADC_MODE, INTERLACE);                   // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  148       Interlace = 1;                      
        MOVS     R0,#+1
        STRB     R0,[R4, #+16]
//  149     }  
//  150   }
//  151   __Set(CH_B_COUPLE, Title[TRACK2][COUPLE].Value);
??Update_Range_1:
        LDRSH    R1,[R6, #+100]
        MOVS     R0,#+11
        _BLF     __Set,??__Set??rT
//  152   __Set(CH_B_RANGE,  Title[TRACK2][RANGE].Value);
        LDRSH    R1,[R6, #+120]
        MOVS     R0,#+12
        _BLF     __Set,??__Set??rT
//  153   __Set(CH_B_OFFSET, (Kb3 * Title[TRACK2][POSI].Value)/256);
        LDRH     R0,[R7, #+2]
        LDRSH    R1,[R5, #+156]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+1
        _BLF     __Set,??__Set??rT
//  154   if(_2_source == HIDE){
        LDRSH    R0,[R6, #+80]
        CBNZ     R0,??Update_Range_2
//  155     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_2
//  156       __Set(CH_B_RANGE,  G_Attr[0].Yp_Max+1);      // B通道合并到A通道
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+12
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  157       __Set(ADC_MODE, INTERLACE);                  // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  158       Interlace = 1;                        
        MOVS     R0,#+1
        STRB     R0,[R4, #+16]
//  159     }
//  160   } 
//  161   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);       // FIFO写指针复位
??Update_Range_2:
        LDRSH    R0,[R8, #+0]
        CBNZ     R0,??Update_Range_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  162 }
??Update_Range_3:
        POP      {R4-R8,PC}
        DATA
??Update_Range_0:
        DC32     Ka3
        CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     Title
//  163 /*******************************************************************************
//  164  Update_Base: 
//  165 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Update_Base
        THUMB
//  166 void Update_Base(void) 
//  167 {
Update_Base:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  168   u16 i;
//  169   
//  170   __Set(ADC_CTRL, EN);       
//  171   i = Title[T_BASE][BASE].Value;
        LDR.N    R4,??Update_Base_0  ;; Title + 336
        MOVS     R1,#+1
//  172   __Set(T_BASE_PSC, X_Attr[i].PSC);
        LDR.N    R6,??Update_Base_0+0x4  ;; V + 128
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        LDRSH    R5,[R4, #+100]
        MOVS     R0,#+20
        UXTH     R5,R5
        MULS     R5,R0,R5
        LDR      R0,[R6, #+0]
        ADDS     R0,R0,R5
        LDRSH    R1,[R0, #+8]
        MOVS     R0,#+7
        _BLF     __Set,??__Set??rT
//  173   __Set(T_BASE_ARR, X_Attr[i].ARR);
        LDR      R0,[R6, #+0]
        ADDS     R0,R0,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+8
        _BLF     __Set,??__Set??rT
//  174   Wait_Cnt = Wait[_T_base];
        LDR.N    R2,??DataTable4  ;; Wait
        LDR.N    R0,??DataTable5  ;; Wait_Cnt
        LDRSH    R1,[R4, #+100]
        LDRH     R1,[R2, R1, LSL #+1]
        STR      R1,[R0, #+0]
//  175   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Base_1
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  176 }
??Update_Base_1:
        POP      {R4-R6,PC}       ;; return
        DATA
??Update_Base_0:
        DC32     Title + 336
        DC32     V + 128
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     Wait_Cnt
//  177 /*******************************************************************************
//  178  Update_Output: 
//  179 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Update_Output
        THUMB
//  180 void Update_Output(void) 
//  181 {
Update_Output:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  182   if(_Kind == SINE){
        LDR.N    R4,??Update_Output_0  ;; Title + 496
        LDR.N    R5,??Update_Output_0+0x4  ;; 0x40020450
        LDR.N    R6,??Update_Output_0+0x8  ;; A_Tab
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Output_1
//  183     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  184     (*((vu32 *)(0x40020400+0x50))) = (u32)&SIN_DATA[0];
        MOVS     R0,R6
        ADDS     R0,R0,#+132
        STR      R0,[R5, #+0]
//  185     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  186   }
//  187   if(_Kind == SAW){
??Update_Output_1:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+2
        BNE.N    ??Update_Output_2
//  188     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  189     (*((vu32 *)(0x40020400+0x50))) = (u32)&SAW_DATA[0];
        ADDW     R0,R6,#+276
        STR      R0,[R5, #+0]
//  190     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  191   }
//  192   if(_Kind == TRIANG){
??Update_Output_2:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Output_3
//  193     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
//  194     (*((vu32 *)(0x40020400+0x50))) = (u32)&TRG_DATA[0];
        ADDS     R6,R6,#+204
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
        STR      R6,[R5, #+0]
//  195     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  196   }
//  197   if(_Kind == DIGI){
??Update_Output_3:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+3
        BNE.N    ??Update_Output_4
//  198     __Set(DIGTAL_PSC, D_Tab[_Frqn].PSC);
        LDRSH    R0,[R4, #+20]
        LDR.N    R5,??Update_Output_0+0xC  ;; D_Tab
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+8]
        MOVS     R0,#+16
        _BLF     __Set,??__Set??rT
//  199     __Set(DIGTAL_ARR, D_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+17
        _BLF     __Set,??__Set??rT
//  200     __Set(DIGTAL_CCR, (D_Tab[_Frqn].ARR+1)/2);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R0,[R0, #+10]
        ADDS     R0,R0,#+1
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R1,R0,#+1
        MOVS     R0,#+18
        _BLF     __Set,??__Set??rT
//  201   }
//  202 }
??Update_Output_4:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??Update_Output_0:
        DC32     Title + 496
        DC32     0x40020450
        DC32     A_Tab
        DC32     D_Tab
        CFI EndBlock cfiBlock4
//  203 /*******************************************************************************
//  204  Update_Trig: 
//  205 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Update_Trig
        THUMB
//  206 void Update_Trig(void) 
//  207 { 
Update_Trig:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  208   if(T1 > T2)  __Set(T_THRESHOLD, (_T1 - _T2));  
//  209   else         __Set(T_THRESHOLD, (_T2 - _T1)); 
        LDR.N    R4,??DataTable6  ;; Title
//  210   __Set(TRIGG_MODE,  (_Tr_source<< 3)+_Tr_kind);
//  211   if(Title[TRIGG][SOURCE].Value == TRACK1){ 
        LDR.N    R6,??DataTable7  ;; V
        LDR.N    R7,??Update_Trig_0  ;; V_Trigg
        ADDW     R0,R4,#+816
        LDRSH    R1,[R0, #+20]
        LDRSH    R0,[R0, #+0]
        ADDW     R5,R4,#+576
        ADDW     R8,R4,#+56
        SUBS     R1,R1,R0
        MOVS     R0,#+34
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        LDRSH    R1,[R5, #+20]
        ADDS     R1,R1,R0, LSL #+3
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        CBNZ     R0,??Update_Trig_1
        LDRSH    R0,[R8, #+0]
        LDRSH    R1,[R7, #+0]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+84]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+40]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  212     __Set(V_THRESHOLD, (((_Vt1-Ka1[_A_Range])*1024)/Ka2[_A_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  213   }
//  214   if(Title[TRIGG][SOURCE].Value == TRACK2){ 
??Update_Trig_1:
        LDRSH    R0,[R5, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Trig_2
        LDRSH    R0,[R8, #+80]
        LDRSH    R1,[R7, #+4]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+96]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+60]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  215     __Set(V_THRESHOLD, (((_Vt2-Kb1[_B_Range])*1024)/Kb2[_B_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  216   }
//  217   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
??Update_Trig_2:
        LDRSH    R0,[R4, #+336]
        CBNZ     R0,??Update_Trig_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  218 }
??Update_Trig_3:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Trig_0:
        DC32     V_Trigg
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     V
//  219 /*******************************************************************************
//  220  Process: 计算处理缓冲区数据 
//  221 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Process
        THUMB
//  222 void Process(void)
//  223 { 
Process:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  224   s16 i, j, k, c_Max;
//  225   
//  226   n= 0;
        LDR.N    R4,??Process_0   ;; V
        SUB      SP,SP,#+28
        CFI CFA R13+64
        MOVS     R0,#+0
        MOV      R8,R0
        STRH     R0,[R4, #+38]
//  227   k =((1024 -_Kp)* 150)/1024 + _X_posi.Value;  // 计算插值运算后窗口位置的修正值
        LDR.N    R0,??Process_0+0x4  ;; Title
        MOVS     R2,#+20
        ADDW     R1,R0,#+436
        STR      R1,[SP, #+8]
        MOVS     R1,R4
        ADDS     R1,R1,#+128
        STR      R1,[SP, #+16]
        LDR      R1,[SP, #+8]
        LDR      R3,[SP, #+16]
//  228   a_Avg =0; b_Avg =0; a_Ssq =0; b_Ssq =0;      // 统计用中间变量初始化
//  229   a_max =_1_posi; b_max =_2_posi; 
        ADDW     R10,R0,#+56
        LDRSH    R1,[R1, #+0]
        LDR      R3,[R3, #+0]
//  230   a_min =_1_posi; b_min =_2_posi;             
//  231 
//  232   if((_3_posi + 20)>= Y_BASE+Y_SIZE)  c_Max = Y_BASE+Y_SIZE-1;
        ADDS     R0,R0,#+236
        MOV      R11,R0
        LDRSH    R0,[R11, #+0]
        MLA      R1,R1,R2,R3
        MOVS     R2,#+150
        MOVS     R3,R0
        LDRH     R1,[R1, #+14]
        ADDS     R3,R3,#+20
        RSBS     R1,R1,#+1024
        MULS     R1,R2,R1
        ASRS     R2,R1,#+9
        ADDS     R1,R1,R2, LSR #+22
        LDR      R2,[SP, #+8]
        ASRS     R1,R1,#+10
        LDRSH    R2,[R2, #+20]
        STR      R8,[R4, #+108]
        STR      R8,[R4, #+112]
        ADDS     R1,R1,R2
        LDRSH    R2,[R10, #+100]
        SXTH     R1,R1
        MOV      R9,R1
        LDRSH    R1,[R10, #+20]
        STR      R8,[R4, #+116]
        STR      R8,[R4, #+120]
        STRB     R1,[R4, #+12]
        STRB     R2,[R4, #+13]
        STRB     R1,[R4, #+14]
        STRB     R2,[R4, #+15]
        CMP      R3,#+200
        BLT.N    ??Process_1
        MOVS     R0,#+199
        B.N      ??Process_2
//  233   else                                c_Max = _3_posi + 20;
??Process_1:
        ADDS     R0,R0,#+20
        SXTH     R0,R0
??Process_2:
        STR      R0,[SP, #+12]
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BNE.W    ??Process_3
//  234   
//  235   if(Interlace == 0){                          // 独立采样模式
//  236     for(i=0; i <4096; i++){
        MOVS     R5,#+0
        B.N      ??Process_4
//  237       if((_T_base > 16)&&(_Status == RUN))  DataBuf[i] = __Read_FIFO(); // 读入32位FIFO数据, 读后指针+1
//  238       else if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
//  239         JumpCnt++;
//  240         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1
//  241       }
//  242       Ch[A] = (DataBuf[i] & 0xFF );              
//  243       a_Avg += Ch[A];                           // 累计直流平均值              
//  244       Tmp = Ch[A]-_1_posi;
//  245       a_Ssq +=(Tmp * Tmp);                      // 统计平方和
//  246       if(Ch[A] > a_max)  a_max = Ch[A];         // 统计最大值  
//  247       if(Ch[A] < a_min)  a_min = Ch[A];         // 统计最小值  
//  248   
//  249       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  250       b_Avg += Ch[B];                           // 累计直流平均值
//  251       Tmp = Ch[B]-_2_posi;
//  252       b_Ssq +=(Tmp * Tmp);                      // 统计平方和
//  253       if(Ch[B] > b_max)  b_max = Ch[B];         // 统计最大值  
//  254       if(Ch[B] < b_min)  b_min = Ch[B];         // 统计最小值  
//  255   
//  256       Ch[C] = ((DataBuf[i] >>16)& 1);
//  257       Ch[D] = ((DataBuf[i] >>17)& 1);
//  258     
//  259       if((i > k)&&(n < 300-1)){                 // 指针到达指定窗口位置
//  260         j =i-k;
//  261         V[A]  = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;      
//  262         V[B]  = Kb1[_B_Range] +(Kb2[_B_Range] *Ch[B])/1024;      //计算当前点的主值
//  263         while(j*1024 - n*_Kp > 0 ){
//  264           V[Ap]= V[A_]+((V[A]-V[A_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_A点的插值
//  265           TrackBuff[n*4 + TRACK1] = V[Ap];
//  266           
//  267           V[Bp]= V[B_]+((V[B]-V[B_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_B点的插值
//  268           TrackBuff[n*4 + TRACK2] = V[Bp];
//  269           
//  270           if(Ch[C])  TrackBuff[n*4 + TRACK3] = c_Max;
//  271           else       TrackBuff[n*4 + TRACK3] = _3_posi;
//  272           
//  273           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
??Process_5:
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
//  274           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+3]
//  275           V[A_] = V[A];  V[B_] = V[B];     //??????????????  
        LDRB     R0,[R4, #+0]
        STRH     R7,[R4, #+38]
//  276           if(n == 300-1) break;
        UXTH     R7,R7
        STRB     R0,[R4, #+2]
        LDRB     R0,[R4, #+1]
        STRB     R0,[R4, #+3]
        LDR.N    R0,??Process_0+0x8  ;; 0x12b
        CMP      R7,R0
        BNE.W    ??Process_6
??Process_7:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+4096
        BGE.W    ??Process_8
??Process_4:
        LDR.N    R0,??Process_0+0xC  ;; DataBuf
        ADDS     R6,R0,R5, LSL #+2
        LDR      R0,[SP, #+8]
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+17
        BLT.N    ??Process_9
        LDRSH    R0,[R11, #+100]
        CBZ      R0,??Process_10
??Process_9:
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_11
        LDRH     R0,[R4, #+36]
        CMP      R5,R0
        BNE.N    ??Process_11
        LDRSH    R1,[R11, #+100]
        CBNZ     R1,??Process_11
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+36]
??Process_10:
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
??Process_11:
        LDR      R2,[R6, #+0]
        LDR      R0,[R4, #+108]
        LDRSH    R3,[R10, #+20]
        LDR      R6,[R4, #+116]
        STRB     R2,[R4, #+8]
        LDRB     R1,[R4, #+8]
        ADDS     R0,R0,R1
        STR      R0,[R4, #+108]
        MOVS     R0,R1
        SUBS     R3,R0,R3
        STR      R3,[R4, #+124]
        MLA      R3,R3,R3,R6
        STR      R3,[R4, #+116]
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
        LDRSH    R6,[R10, #+100]
        LDR      R7,[R4, #+120]
        LSRS     R1,R2,#+8
        STRB     R1,[R4, #+9]
        LDRB     R3,[R4, #+9]
        LDR      R1,[R4, #+112]
        ADDS     R1,R1,R3
        STR      R1,[R4, #+112]
        MOVS     R1,R3
        SUBS     R6,R1,R6
        STR      R6,[R4, #+124]
        MLA      R6,R6,R6,R7
        STR      R6,[R4, #+120]
        LDRB     R6,[R4, #+13]
        CMP      R6,R3
        IT      CC 
        STRBCC   R3,[R4, #+13]
        LDRB     R6,[R4, #+15]
        CMP      R3,R6
        IT      CC 
        STRBCC   R3,[R4, #+15]
        LSRS     R3,R2,#+16
        MOVS     R6,#+1
        ANDS     R6,R6,R3
        STRB     R6,[R4, #+10]
        LSRS     R2,R2,#+17
        MOVS     R3,#+1
        ANDS     R3,R3,R2
        STRB     R3,[R4, #+11]
        CMP      R9,R5
        BGE.N    ??Process_7
        LDRH     R2,[R4, #+38]
        LDR.N    R3,??Process_0+0x8  ;; 0x12b
        CMP      R2,R3
        BCS.N    ??Process_7
        MOV      R3,R9
        SUBS     R6,R5,R3
        LDRSH    R3,[R10, #+0]
        SXTH     R6,R6
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+40]
        MULS     R2,R0,R2
        ADDS     R0,R4,R3
        LDRSB    R0,[R0, #+84]
        ASRS     R3,R2,#+9
        ADDS     R2,R2,R3, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R0,R0,R2
        LDRSH    R2,[R10, #+80]
        STRB     R0,[R4, #+0]
        ADDS     R0,R4,R2, LSL #+1
        LDRH     R0,[R0, #+60]
        MULS     R0,R1,R0
        ADDS     R1,R4,R2
        LDRSB    R1,[R1, #+96]
        ASRS     R2,R0,#+9
        ADDS     R0,R0,R2, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+1]
        LDR      R0,[SP, #+8]
        LDR      R2,[SP, #+16]
        MOVS     R1,#+20
        LDRSH    R0,[R0, #+0]
        LDR      R2,[R2, #+0]
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
??Process_6:
        LDR      R2,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LSLS     R1,R6,#+10
        LDRH     R2,[R2, #+14]
        MOVS     R0,R7
        MLS      R1,R0,R2,R1
        CMP      R1,#+1
        BLT.W    ??Process_7
        SUBS     R1,R6,#+1
        LSLS     R1,R1,#+10
        STR      R1,[SP, #+24]
        LDRB     R1,[R4, #+2]
        LDRB     R2,[R4, #+0]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+24]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        LDR.N    R2,??DataTable12  ;; TrackBuff
        STRB     R1,[R4, #+4]
        ADDS     R2,R2,R0, LSL #+2
        STR      R2,[SP, #+0]
        STRB     R1,[R2, #+0]
        LDR      R3,[SP, #+4]
        LDRB     R1,[R4, #+3]
        LDRB     R2,[R4, #+1]
        LDRH     R3,[R3, #+14]
        SUBS     R2,R2,R1
        MULS     R0,R3,R0
        LDR      R3,[SP, #+24]
        SUBS     R0,R0,R3
        MULS     R2,R0,R2
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+5]
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+1]
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        LDR      R0,[SP, #+0]
        ITTEE   EQ 
        LDRHEQ   R1,[R11, #+0]
        STRBEQ   R1,[R0, #+2]
        LDRNE    R1,[SP, #+12]
        STRBNE   R1,[R0, #+2]
        B.N      ??Process_5
//  277         }
//  278       }
//  279     }
//  280   } else {                            // 交替采样模式
//  281       
//  282     if(_2_source == HIDE){                         // B通道合并到A通道时
??Process_3:
        LDRSH    R0,[R10, #+40]
        CMP      R0,#+0
        ITTEE   NE 
        LSLNE    R0,R1,#+12
        STRNE    R0,[R4, #+108]
//  283       b_Avg = _2_posi*4096;
        LSLEQ    R0,R2,#+12
        STREQ    R0,[R4, #+112]
//  284     } else {                                       // A通道合并到B通道时
//  285       a_Avg = _1_posi*4096;
//  286     }
//  287     for(i=0; i <8192; i++){
        MOVS     R5,#+0
??Process_12:
        LDR.N    R1,??Process_0+0xC  ;; DataBuf
        ADDS     R0,R5,R5, LSR #+31
        ASRS     R0,R0,#+1
        ADDS     R6,R1,R0, LSL #+2
        LDRSH    R0,[R11, #+100]
        CBNZ     R0,??Process_13
//  288       if(_Status == RUN)  DataBuf[i/2] = __Read_FIFO(); // 读入32位FIFO数据, 读后指针+1
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
//  289       Ch[A] = (DataBuf[i/2] & 0xFF );              
??Process_13:
        LDR      R0,[R6, #+0]
//  290       Ch[B] = ((DataBuf[i/2] >> 8) & 0xFF);       
        MOVS     R2,#+1
        STRB     R0,[R4, #+8]
        LSRS     R1,R0,#+8
        STRB     R1,[R4, #+9]
        LSRS     R1,R0,#+16
        ANDS     R2,R2,R1
//  291   
//  292       Ch[C] = ((DataBuf[i/2] >>16)& 1);
//  293       Ch[D] = ((DataBuf[i/2] >>17)& 1);
        LSRS     R0,R0,#+17
        MOVS     R1,#+1
        ANDS     R1,R1,R0
//  294     
//  295       if(_2_source == HIDE){                 // B通道合并到A通道时
        LDRSB    R0,[R4, #+80]
        STRB     R1,[R4, #+11]
        LDRSH    R1,[R10, #+40]
        STRB     R2,[R4, #+10]
        CMP      R1,#+0
        BNE.N    ??Process_14
//  296         Ch[B] += Kab;
        LDRB     R2,[R4, #+9]
//  297         a_Avg += (Ch[A]+Ch[B])/2;                                   // 累计直流平均值                                   
        LDRB     R1,[R4, #+8]
        LDR      R6,[R4, #+108]
        ADDS     R0,R2,R0
        STRB     R0,[R4, #+9]
        MOVS     R2,R1
        UXTB     R0,R0
        ADDS     R3,R2,R0
        ADDS     R3,R3,R3, LSR #+31
        ADDS     R3,R6,R3, ASR #+1
        STR      R3,[R4, #+108]
        LDRSH    R3,[R10, #+20]
        SUBS     R7,R2,R3
//  298         Tmp    = (Ch[A]-_1_posi);
//  299         a_Ssq += (Tmp * Tmp)/2;
        MOVS     R6,R7
        STR      R7,[R4, #+124]
        MULS     R6,R7,R6
        LDR      R7,[R4, #+116]
        ADDS     R6,R6,R6, LSR #+31
//  300         Tmp    = (Ch[B]-_1_posi);
        SUBS     R3,R0,R3
        ADDS     R6,R7,R6, ASR #+1
//  301         a_Ssq += (Tmp * Tmp)/2;                                       // 统计平方和                    
        MOVS     R7,R3
        STR      R3,[R4, #+124]
        MULS     R7,R3,R7
        ADDS     R3,R7,R7, LSR #+31
        STR      R6,[R4, #+116]
        ADDS     R3,R6,R3, ASR #+1
        STR      R3,[R4, #+116]
//  302         if(Ch[A] > a_max)  a_max = Ch[A];          
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
//  303         if(Ch[B] > a_max)  a_max = Ch[B];                          // 统计最大值 
        LDRB     R3,[R4, #+12]
        CMP      R3,R0
        IT      CC 
        STRBCC   R0,[R4, #+12]
//  304         if(Ch[A] < a_min)  a_min = Ch[A];         
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
//  305         if(Ch[B] < a_min)  a_min = Ch[B];                          // 统计最小值  
        LDRB     R1,[R4, #+14]
        CMP      R0,R1
        IT      CC 
        STRBCC   R0,[R4, #+14]
        LDRSH    R3,[R10, #+0]
        ADDS     R1,R4,R3, LSL #+1
        LDRH     R1,[R1, #+40]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+84]
        MULS     R2,R1,R2
        ASRS     R6,R2,#+9
//  306         V[A] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;         //计算当前第1点的主值
//  307         V[B] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[B])/1024;         //计算当前第2点的主值
        MULS     R1,R0,R1
        ASRS     R0,R1,#+9
        ADDS     R2,R2,R6, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R2,R3,R2
        STRB     R2,[R4, #+0]
        ADDS     R0,R1,R0, LSR #+22
        B.N      ??Process_15
        DATA
??Process_0:
        DC32     V
        DC32     Title
        DC32     0x12b
        DC32     DataBuf
        THUMB
//  308         
//  309       } else {                            // A通道合并到B通道时
//  310         
//  311         Ch[A] -= Kab;
??Process_14:
        LDRB     R1,[R4, #+8]
//  312         b_Avg += Ch[A]+Ch[B]/2;                                      // 累计直流平均值                                   
        LDRB     R2,[R4, #+9]
        LDR      R3,[R4, #+112]
        SUBS     R0,R1,R0
        STRB     R0,[R4, #+8]
        UXTB     R0,R0
        MOVS     R1,R0
        LSRS     R6,R2,#+1
        ADDS     R6,R1,R6
        ADDS     R3,R3,R6
        STR      R3,[R4, #+112]
        LDRSH    R3,[R10, #+100]
        SUBS     R7,R1,R3
//  313         Tmp    = Ch[A]-_2_posi;
//  314         b_Ssq += (Tmp * Tmp)/2;
        MOVS     R6,R7
        STR      R7,[R4, #+124]
        MULS     R6,R7,R6
        LDR      R7,[R4, #+120]
        ADDS     R6,R6,R6, LSR #+31
        SUBS     R3,R2,R3
        ADDS     R6,R7,R6, ASR #+1
//  315         Tmp    = Ch[B]-_2_posi;
//  316         b_Ssq += (Tmp * Tmp)/2;                                       // 统计平方和                    
        MOVS     R7,R3
        STR      R3,[R4, #+124]
        MULS     R7,R3,R7
        ADDS     R3,R7,R7, LSR #+31
        STR      R6,[R4, #+120]
        ADDS     R3,R6,R3, ASR #+1
        STR      R3,[R4, #+120]
//  317         if(Ch[A] > b_max)  b_max = Ch[A];          
        LDRB     R3,[R4, #+13]
        CMP      R3,R0
        IT      CC 
        STRBCC   R0,[R4, #+13]
//  318         if(Ch[B] > b_max)  b_max = Ch[B];                          // 统计最大值 
        LDRB     R3,[R4, #+13]
        CMP      R3,R2
        IT      CC 
        STRBCC   R2,[R4, #+13]
//  319         if(Ch[A] < b_min)  b_min = Ch[A];         
        LDRB     R3,[R4, #+15]
        CMP      R0,R3
        IT      CC 
        STRBCC   R0,[R4, #+15]
//  320         if(Ch[B] < b_min)  b_min = Ch[B];                          // 统计最小值  
        LDRB     R0,[R4, #+15]
        CMP      R2,R0
        IT      CC 
        STRBCC   R2,[R4, #+15]
        LDRSH    R3,[R10, #+80]
        ADDS     R0,R4,R3, LSL #+1
        LDRH     R0,[R0, #+60]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+96]
        MULS     R1,R0,R1
        ASRS     R6,R1,#+9
//  321         V[A] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[A])/1024;        //计算当前第1点的主值
//  322         V[B] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[B])/1024;        //计算当前第2点的主值
        MULS     R0,R2,R0
        ADDS     R1,R1,R6, LSR #+22
        ASRS     R1,R1,#+10
        ADDS     R1,R3,R1
        STRB     R1,[R4, #+0]
        ASRS     R1,R0,#+9
        ADDS     R0,R0,R1, LSR #+22
??Process_15:
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+1]
//  323       }
//  324         
//  325       if((i > k)&&(n < 300-1)){                 // 第1点指针到达指定窗口位置
        LDR      R0,[SP, #+8]
        LDR      R2,[SP, #+16]
        MOVS     R1,#+20
        LDRSH    R0,[R0, #+0]
        LDR      R2,[R2, #+0]
        CMP      R9,R5
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
        LDRH     R0,[R11, #+0]
        STRH     R0,[SP, #+20]
        BGE.N    ??Process_16
        LDRH     R0,[R4, #+38]
        LDR.N    R1,??Process_17  ;; 0x12b
        CMP      R0,R1
        BCS.N    ??Process_16
//  326         j =i - k - 1;
        MOV      R1,R9
        SUBS     R6,R5,R1
        SUBS     R6,R6,#+1
        SXTH     R6,R6
//  327         while(j*1024 - n*_Kp > 0 ){
??Process_18:
        LDR      R2,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LSLS     R0,R6,#+10
        LDRH     R2,[R2, #+14]
        MOVS     R1,R7
        MLS      R2,R1,R2,R0
        CMP      R2,#+1
        BLT.N    ??Process_16
//  328           V[Ap] =V[B_]+((V[A]-V[B_])*((n *_Kp)-j*1024))/1024;   //计算当前第1点的插值
        LDRB     R2,[R4, #+3]
        LDRB     R3,[R4, #+0]
        SUBS     R3,R3,R2
        MOV      R12,R3
        LDR      R3,[SP, #+4]
        LDRH     R3,[R3, #+14]
        MULS     R3,R1,R3
        SUBS     R0,R3,R0
        MOV      R3,R12
        MULS     R3,R0,R3
        ASRS     R0,R3,#+9
        ADDS     R0,R3,R0, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R2,R0
//  329 //          V[Ap] =V[A];
//  330           TrackBuff[n*4 + TRACK1] = V[Ap];
        LDR.N    R2,??DataTable12  ;; TrackBuff
        STRB     R0,[R4, #+4]
        ADDS     R1,R2,R1, LSL #+2
        STR      R1,[SP, #+0]
        STRB     R0,[R1, #+0]
//  331           TrackBuff[n*4 + TRACK2] = V[Ap];
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+1]
//  332           if(Ch[C])  TrackBuff[n*4 + TRACK3] = c_Max;
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        LDR      R0,[SP, #+0]
        ITTEE   EQ 
        LDRHEQ   R1,[SP, #+20]
        STRBEQ   R1,[R0, #+2]
        LDRNE    R1,[SP, #+12]
        STRBNE   R1,[R0, #+2]
//  333           else       TrackBuff[n*4 + TRACK3] = _3_posi;
//  334           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
//  335           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+3]
//  336           if(n == 300-1)  break;
        LDR.N    R0,??Process_17  ;; 0x12b
        STRH     R7,[R4, #+38]
        UXTH     R7,R7
        CMP      R7,R0
        BNE.N    ??Process_18
//  337         }
//  338       }
//  339       i++;
??Process_16:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        STR      R5,[SP, #+0]
//  340       if((i > k)&&(n < 300-1)){                 // 第2点指针到达指定窗口位置
        LDR      R0,[SP, #+0]
        CMP      R9,R0
        BGE.N    ??Process_19
        LDRH     R0,[R4, #+38]
        LDR.N    R1,??Process_17  ;; 0x12b
        CMP      R0,R1
        BCS.N    ??Process_19
//  341         j =i - k - 1;
        LDR      R0,[SP, #+0]
        MOV      R1,R9
        SUBS     R6,R0,R1
        SUBS     R6,R6,#+1
        SXTH     R6,R6
//  342         while(j*1024 - n*_Kp > 0 ){
??Process_20:
        LDR      R2,[SP, #+4]
        LDRH     R5,[R4, #+38]
        LSLS     R1,R6,#+10
        LDRH     R2,[R2, #+14]
        MOVS     R0,R5
        MLS      R2,R0,R2,R1
        CMP      R2,#+1
        BLT.N    ??Process_19
        LDR      R7,[SP, #+4]
        LDRB     R2,[R4, #+0]
        LDRB     R3,[R4, #+1]
        LDRH     R7,[R7, #+14]
        SUBS     R3,R3,R2
        MULS     R7,R0,R7
        SUBS     R1,R7,R1
        MULS     R3,R1,R3
        ASRS     R1,R3,#+9
        ADDS     R1,R3,R1, LSR #+22
        ASRS     R1,R1,#+10
        ADDS     R1,R2,R1
//  343           V[Bp] =V[A]+((V[B]-V[A])*((n *_Kp)-j*1024))/1024;   //计算当前第2点的插值
//  344 //          V[Bp] =V[B];
//  345           TrackBuff[n*4 + TRACK1] = V[Bp];
        LDR.N    R2,??DataTable12  ;; TrackBuff
        STRB     R1,[R4, #+5]
        ADDS     R7,R2,R0, LSL #+2
        STRB     R1,[R7, #+0]
//  346           TrackBuff[n*4 + TRACK2] = V[Bp];
        STRB     R1,[R7, #+1]
//  347           
//  348           if(Ch[C])  TrackBuff[n*4 + TRACK3] = c_Max;
        LDRB     R0,[R4, #+10]
        CMP      R0,#+0
        ITTEE   EQ 
        LDRHEQ   R0,[SP, #+20]
        STRBEQ   R0,[R7, #+2]
        LDRNE    R0,[SP, #+12]
        STRBNE   R0,[R7, #+2]
//  349           else       TrackBuff[n*4 + TRACK3] = _3_posi;
//  350           
//  351           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
        BL       CH_D_Data
        STRB     R0,[R7, #+3]
//  352           
//  353           n++;
//  354           V[B_] = V[B];       
        LDRB     R0,[R4, #+1]
        ADDS     R5,R5,#+1
        STRH     R5,[R4, #+38]
        STRB     R0,[R4, #+3]
//  355           if(n == 300-1)  break;
        LDR.N    R0,??Process_17  ;; 0x12b
        UXTH     R5,R5
        CMP      R5,R0
        BNE.N    ??Process_20
//  356         }
//  357       }
//  358     }
??Process_19:
        LDR      R5,[SP, #+0]
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+8192
        BLT.W    ??Process_12
//  359   }
//  360   for(i=0; i<4; i++){                                    // 消除屏幕端点连线
??Process_8:
        MOVS     R0,#+0
//  361     for(j=0; j<4; j++){
??Process_21:
        MOVS     R6,#+0
//  362       TrackBuff[(i+0)*4+ j]   = TrackBuff[(i+1)*4 + j];
??Process_22:
        LDR.N    R2,??DataTable12  ;; TrackBuff
        ADDS     R1,R6,R0, LSL #+2
        ADDS     R1,R2,R1
        LDRB     R2,[R1, #+4]
        STRB     R2,[R1, #+0]
//  363       TrackBuff[(299-i)*4+ j] = TrackBuff[(298-i)*4 + j];
        LDR.N    R2,??DataTable12  ;; TrackBuff
        RSBS     R1,R0,#+0
        ADDS     R1,R6,R1, LSL #+2
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+1192
        LDRB     R2,[R1, #+0]
//  364     }
        ADDS     R6,R6,#+1
        CMP      R6,#+4
        STRB     R2,[R1, #+4]
        BLT.N    ??Process_22
//  365   }
        ADDS     R0,R0,#+1
        CMP      R0,#+4
        BLT.N    ??Process_21
//  366 }
        ADD      SP,SP,#+28
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??Process_17:
        DC32     0x12b
        CFI EndBlock cfiBlock6

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     TrackBuff
//  367 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function CH_D_Data
        THUMB
//  368 u8 CH_D_Data(void)  //计算生成CH_D通道的显示数据
//  369 {
//  370   s32 Tmp;
//  371   
//  372   switch (_4_source){  
CH_D_Data:
        LDR.N    R1,??DataTable13  ;; Title
        LDR.N    R3,??DataTable14  ;; V
        PUSH     {R4-R11}
        CFI R11 Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+12
        CFI CFA R13+44
        LDRSH    R0,[R1, #+316]
        MOVS     R2,R1
        LDRSH    R9,[R1, #+156]!
        LDRSH    R1,[R1, #+100]
        MOV      R8,R3
        LDRB     R3,[R8, #+0]
        LDRB     R5,[R8, #+5]
        LDRB     R6,[R8, #+16]
        ADDS     R2,R2,#+16
        LDRSH    R4,[R2, #+60]
        ADDS     R5,R0,R5
        SUBS     R5,R5,R9
        STR      R5,[SP, #+8]
        LDRB     R5,[R8, #+4]
        ADDS     R3,R0,R3
        SUBS     R3,R3,R4
        ADDS     R5,R0,R5
        SUBS     R4,R5,R4
        LDRB     R5,[R8, #+11]
        STR      R4,[SP, #+4]
        LDR.N    R4,??CH_D_Data_1  ;; FileBuff
        SUBS     R1,R1,#+2
        MOV      R10,R4
        LDRH     R4,[R8, #+38]
        ADDS     R11,R4,R10
        LDRB     R4,[R8, #+1]
        CMP      R1,#+7
        STR      R4,[SP, #+0]
        LDRSH    R4,[R2, #+80]
        LDRSH    R2,[R2, #+0]
        BHI.N    ??CH_D_Data_2
        TBB      [PC, R1]
        DATA
??CH_D_Data_0:
        DC8      +4,+16,+26,+26
        DC8      +33,+40,+45,+52
        THUMB
//  373   case A_add_B:
//  374     if(Interlace == 0){                          // 独立采样模式
??CH_D_Data_3:
        CBNZ     R6,??CH_D_Data_4
//  375       Tmp = _4_posi +(V[A]-_1_posi)+(V[B]-_2_posi);
        LDR      R0,[SP, #+0]
        ADDS     R0,R3,R0
        SUBS     R0,R0,R9
        B.N      ??CH_D_Data_5
//  376     } else {                                     // 交替采样模式
//  377       Tmp = _4_posi;
//  378       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_4:
        CBZ      R2,??CH_D_Data_6
        LDR      R0,[SP, #+4]
//  379       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_6:
        CMP      R4,#+0
        BEQ.N    ??CH_D_Data_5
??CH_D_Data_7:
        LDR      R0,[SP, #+8]
        B.N      ??CH_D_Data_5
//  380     } break;
//  381   case A_sub_B:
//  382     if(Interlace == 0){                          // 独立采样模式
??CH_D_Data_8:
        CBNZ     R6,??CH_D_Data_9
//  383       Tmp = _4_posi +(V[A]-_1_posi)-(V[B]-_2_posi);  break;
        LDR      R0,[SP, #+0]
        SUBS     R0,R3,R0
        ADDS     R0,R9,R0
        B.N      ??CH_D_Data_5
//  384     } else {                                     // 交替采样模式
//  385       Tmp = _4_posi;
//  386       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_9:
        CBZ      R2,??CH_D_Data_10
        LDR      R0,[SP, #+4]
//  387       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_10:
        CBZ      R4,??CH_D_Data_5
        B.N      ??CH_D_Data_7
//  388     } break;
//  389   case C_and_D:
//  390     Tmp = _4_posi + 20 *(Ch[C] & Ch[D]);  break;
??CH_D_Data_11:
        LDRB     R1,[R8, #+10]
        ANDS     R5,R5,R1
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
        B.N      ??CH_D_Data_5
//  391   case C_or_D:
//  392     Tmp =  _4_posi + 20 *(Ch[C] & Ch[D]);  break;
//  393   case FILE1:
//  394     Tmp = FileBuff[n] - FileBuff[299] +_4_posi;  break;
??CH_D_Data_12:
        LDRB     R1,[R11, #+0]
        LDRB     R2,[R10, #+299]
??CH_D_Data_13:
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  395   case FILE2:
//  396     Tmp = FileBuff[n+300] - FileBuff[599] +_4_posi;  break;
??CH_D_Data_14:
        LDRB     R1,[R11, #+300]
        LDRB     R2,[R10, #+599]
        B.N      ??CH_D_Data_13
//  397   case FILE3:
//  398     Tmp = FileBuff[n+600] - FileBuff[899] +_4_posi;  break;
??CH_D_Data_15:
        LDRB     R1,[R11, #+600]
        LDRB     R2,[R10, #+899]
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  399   case FILE4:
//  400     Tmp = FileBuff[n+900] - FileBuff[1199] +_4_posi;  break;
??CH_D_Data_16:
        LDRB     R1,[R11, #+900]
        LDRB     R2,[R10, #+1199]
        B.N      ??CH_D_Data_13
//  401   default:
//  402     Tmp = _4_posi + 20 * Ch[D];
??CH_D_Data_2:
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
//  403   }
//  404   if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
??CH_D_Data_5:
        CMP      R0,#+200
        BLT.N    ??CH_D_Data_17
        MOVS     R0,#+199
        B.N      ??CH_D_Data_18
//  405   else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??CH_D_Data_17:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
//  406   return Tmp;
??CH_D_Data_18:
        UXTB     R0,R0
        ADD      SP,SP,#+12
        CFI CFA R13+32
        POP      {R4-R11}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??CH_D_Data_1:
        DC32     FileBuff
        CFI EndBlock cfiBlock7
//  407 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     V
//  408 /*******************************************************************************
//  409  Synchro: 扫描同步处理，按设定模式显示波形 
//  410 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function Synchro
        THUMB
//  411 void Synchro(void)  //扫描同步方式共有：AUTO、NORM、SIGN、NONE、SCAN 5种模式
//  412 { 
//  413   u16  i;
//  414 
//  415   switch (_Mode){ 
Synchro:
        LDR.N    R0,??DataTable15  ;; Title
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        LDR.N    R4,??DataTable16  ;; V
        MOV      R8,R0
        ADDW     R0,R8,#+576
        LDRSH    R1,[R0, #+0]
        LDRSH    R0,[R0, #+20]
        ADDW     R7,R8,#+336
        MOVS     R5,#+0
        ADDS     R1,R0,R1, LSL #+3
        LDR.N    R0,??DataTable17  ;; Wait
        MOV      R9,R0
        LDR.N    R0,??DataTable18  ;; TrackBuff
        MOV      R11,R0
        LDR.N    R0,??DataTable19  ;; Wait_Cnt
        MOV      R10,R0
        LDRSH    R0,[R7, #+80]
        CMP      R0,#+4
        BHI.N    ??Synchro_1
        TBB      [PC, R0]
        DATA
??Synchro_0:
        DC8      +3,+29,+56,+64
        DC8      +64,+0
        THUMB
//  416   case AUTO:
//  417     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_2:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  418     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_3
//  419       Process();                                  // 生成新的显示波形
??Synchro_4:
        BL       Process
//  420       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R7, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R10, #+0]
        B.N      ??Synchro_1
//  421     } else if(Wait_Cnt==0){
??Synchro_3:
        LDR      R0,[R10, #+0]
        CMP      R0,#+0
        BNE.N    ??Synchro_1
//  422       if(JumpCnt >= 4095)  JumpCnt = 0;         
        LDRH     R0,[R4, #+36]
        LDR.N    R1,??Synchro_5   ;; 0xfff
        CMP      R0,R1
        BCC.N    ??Synchro_4
        STRH     R5,[R4, #+36]
        B.N      ??Synchro_4
//  423       Process();   
//  424       Wait_Cnt = Wait[_T_base];
//  425     } break;
//  426   case NORM:
//  427     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_6:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  428     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CMP      R0,#+0
        BNE.N    ??Synchro_4
//  429       Process();                                  // 生成新的显示波形
//  430       Wait_Cnt = Wait[_T_base];
//  431     } else if(Wait_Cnt==0){
        LDR      R0,[R10, #+0]
        CBNZ     R0,??Synchro_1
//  432       for(i=0; i<4*X_SIZE; ++i)  TrackBuff[i] = 0;// 清除旧的显示波形
        MOVS     R3,#+0
??Synchro_7:
        MOV      R2,R11
        STRB     R5,[R2, R0]
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        MOVS     R2,#+1200
        CMP      R0,R2
        BCC.N    ??Synchro_7
//  433       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R7, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R10, #+0]
        B.N      ??Synchro_1
//  434     } break;
//  435   case SIGN:
//  436     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_8:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  437     if(__Get(FIFO_START)!=0)  Process();          // 生成新的显示波形
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_1
        B.N      ??Synchro_9
//  438     break;
//  439   case NONE:
//  440   case SCAN:
//  441     __Set(TRIGG_MODE, UNCONDITION);               // 设为无条件触发
??Synchro_10:
        MOVS     R1,#+32
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  442     Process();                                    // 生成当前显示波形
??Synchro_9:
        BL       Process
//  443     break;
//  444   }
//  445   Draw_Window();                                  // 刷新屏幕波形显示区
??Synchro_1:
        _BLF     Draw_Window,??Draw_Window??rT
//  446 
//  447   if((_Status == RUN)&&(__Get(FIFO_FULL)!=0)){    // FIFO is full
        LDRSH    R0,[R7, R5]
        MOV      R6,R8
        ADDS     R6,R6,#+56
        CMP      R0,#+0
        BNE.N    ??Synchro_11
        MOVS     R0,#+3
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_11
//  448     __Set(FIFO_CLR, W_PTR);                       // FIFO写指针复位
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  449     Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R7, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R10, #+0]
//  450     JumpCnt =0;
//  451     if(_Mode == SIGN){
        LDRSH    R0,[R7, #+80]
        STRH     R5,[R4, #+36]
        CMP      R0,#+2
        BNE.N    ??Synchro_12
//  452       _Status = HOLD;                             // 一帧完后，进入暂停
        MOVS     R0,#+1
        STRH     R0,[R7, #+0]
//  453       _State.Flag |= UPDAT;
        LDRB     R0,[R7, #+2]
        ORRS     R0,R0,#0x2
        STRB     R0,[R7, #+2]
        B.N      ??Synchro_11
//  454     }
//  455     if(_Mode == SCAN){
??Synchro_12:
        CMP      R0,#+4
        BNE.N    ??Synchro_11
//  456       for(i=0; i<X_SIZE; i++){                    // 重建当前轨迹基线                   
        MOVS     R0,#+0
??Synchro_13:
        LDRH     R2,[R6, #+20]
        ADDS     R1,R11,R0, LSL #+2
//  457         TrackBuff[i*4 + TRACK1] = _1_posi;
//  458         TrackBuff[i*4 + TRACK2] = _2_posi; 
//  459         TrackBuff[i*4 + TRACK3] = _3_posi; 
//  460         TrackBuff[i*4 + TRACK4] = _4_posi;
        ADDS     R0,R0,#+1
        STRB     R2,[R1, #+0]
        LDRH     R2,[R6, #+100]
        UXTH     R0,R0
        STRB     R2,[R1, #+1]
        MOV      R2,R8
        LDRH     R3,[R2, #+236]!
        ADDS     R2,R2,#+80
        STRB     R3,[R1, #+2]
        LDRH     R2,[R2, #+0]
        STRB     R2,[R1, #+3]
        MOVS     R2,#+300
        CMP      R0,R2
        BCC.N    ??Synchro_13
??Synchro_11:
        LDRSH    R1,[R6, R5]
        LDR      R2,[R4, #+108]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+84]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        LSRS     R2,R2,#+12
        MULS     R1,R2,R1
        LDR      R2,[R4, #+112]
        LSRS     R1,R1,#+10
        ADDS     R0,R0,R1
        LDRSH    R1,[R6, #+20]
        LSRS     R2,R2,#+12
        SUBS     R0,R0,R1
        LDRSH    R1,[R6, #+80]
        STRH     R0,[R4, #+18]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+96]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+60]
        MULS     R1,R2,R1
        LSRS     R1,R1,#+10
        ADDS     R0,R0,R1
        LDRSH    R1,[R6, #+100]
        SUBS     R0,R0,R1
        STRH     R0,[R4, #+28]
//  461       }
//  462     }
//  463   }    
//  464   A_Vdc = Ka1[_A_Range] +(Ka2[_A_Range]*(a_Avg/4096))/1024 - _1_posi;  
//  465   B_Vdc = Kb1[_B_Range] +(Kb2[_B_Range]*(b_Avg/4096))/1024 - _2_posi;  
//  466 
//  467   A_Rms = Ka1[_A_Range] +(Ka2[_A_Range]*Int_sqrt(a_Ssq/4096))/1024;
        LDR      R0,[R4, #+116]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R6, R5]
        ADDS     R2,R4,R1
        LDRSB    R2,[R2, #+84]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        MULS     R1,R0,R1
        ADDS     R0,R2,R1, LSR #+10
        STRH     R0,[R4, #+26]
//  468   B_Rms = Kb1[_B_Range] +(Kb2[_B_Range]*Int_sqrt(b_Ssq/4096))/1024;
        LDR      R0,[R4, #+120]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R6, #+80]
        LDRSH    R3,[R6, R5]
        LDRSH    R10,[R6, #+20]
        ADDS     R2,R4,R1, LSL #+1
        LDRH     R2,[R2, #+60]
        ADDS     R1,R4,R1
        MOV      R9,R2
        LDRSB    R2,[R1, #+96]
        LDR.N    R1,??Synchro_5+0x4  ;; B_Rms
//  469 
//  470   A_Max = Ka1[_A_Range] +(Ka2[_A_Range]*a_max)/1024 - _1_posi;
//  471   B_Max = Kb1[_B_Range] +(Kb2[_B_Range]*b_max)/1024 - _2_posi;
        MOV      R11,R9
        MOV      R8,R1
        MOV      R1,R9
        MOV      R9,R2
        MULS     R1,R0,R1
        ADDS     R0,R2,R1, LSR #+10
        LDRB     R1,[R4, #+12]
        LDRSH    R2,[R6, #+100]
        STRH     R0,[R8, #+0]
        ADDS     R0,R4,R3, LSL #+1
        LDRH     R0,[R0, #+40]
        ADDS     R3,R4,R3
        LDRSB    R7,[R3, #+84]
        MULS     R1,R0,R1
        ASRS     R3,R1,#+9
        ADDS     R1,R1,R3, LSR #+22
        LDRB     R3,[R4, #+13]
        ASRS     R1,R1,#+10
        ADDS     R1,R7,R1
        SUBS     R1,R1,R10
        MUL      R3,R11,R3
        STRH     R1,[R4, #+22]
        ASRS     R6,R3,#+9
        ADDS     R3,R3,R6, LSR #+22
        ASRS     R3,R3,#+10
        MOV      R6,R9
        ADDS     R3,R6,R3
//  472  
//  473   A_Min = Ka1[_A_Range] +(Ka2[_A_Range]*a_min)/1024 - _1_posi;
        LDRB     R6,[R4, #+14]
        SUBS     R3,R3,R2
        STRH     R3,[R4, #+32]
        MULS     R0,R6,R0
        ASRS     R6,R0,#+9
        ADDS     R0,R0,R6, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R7,R0
        SUBS     R6,R0,R10
//  474   B_Min = Kb1[_B_Range] +(Kb2[_B_Range]*b_min)/1024 - _2_posi;
        LDRB     R0,[R4, #+15]
        STRH     R6,[R4, #+24]
        MUL      R0,R11,R0
        ASRS     R7,R0,#+9
        ADDS     R0,R0,R7, LSR #+22
        ASRS     R0,R0,#+10
        MOV      R7,R9
        ADDS     R0,R7,R0
        SUBS     R0,R0,R2
//  475     
//  476   if(A_Rms < 3)  A_Rms = 0;
        LDRSH    R2,[R4, #+26]
        STRH     R0,[R4, #+34]
        CMP      R2,#+3
        IT      LT 
        STRHLT   R5,[R4, #+26]
//  477   if(B_Rms < 3)  B_Rms = 0;
        LDRSH    R2,[R8, #+0]
        CMP      R2,#+3
        ITT     LT 
        MOVLT    R2,#+0
        STRHLT   R2,[R8, #+0]
//  478   
//  479   if((A_Vdc < 3)&&(A_Vdc > -3))  A_Vdc = 0;
        LDRSH    R7,[R4, #+18]
        MVNS     R2,#+1
        CMP      R7,#+3
        BGE.N    ??Synchro_14
        CMP      R7,R2
        IT      GE 
        STRHGE   R5,[R4, #+18]
//  480   if((B_Vdc < 3)&&(B_Vdc > -3))  B_Vdc = 0;
??Synchro_14:
        LDRSH    R7,[R4, #+28]
        CMP      R7,#+3
        BGE.N    ??Synchro_15
        CMP      R7,R2
        IT      GE 
        STRHGE   R5,[R4, #+28]
//  481   if((A_Max < 3)&&(A_Max > -3))  A_Max = 0;
??Synchro_15:
        SXTH     R1,R1
        CMP      R1,#+3
        BGE.N    ??Synchro_16
        CMP      R1,R2
        IT      GE 
        STRHGE   R5,[R4, #+22]
//  482   if((B_Max < 3)&&(B_Max > -3))  B_Max = 0;
??Synchro_16:
        SXTH     R3,R3
        CMP      R3,#+3
        BGE.N    ??Synchro_17
        CMP      R3,R2
        IT      GE 
        STRHGE   R5,[R4, #+32]
//  483   if((A_Min < 3)&&(A_Min > -3))  A_Min = 0;
??Synchro_17:
        SXTH     R6,R6
        CMP      R6,#+3
        BGE.N    ??Synchro_18
        CMP      R6,R2
        IT      GE 
        STRHGE   R5,[R4, #+24]
//  484   if((B_Min < 3)&&(B_Min > -3))  B_Min = 0;
??Synchro_18:
        SXTH     R0,R0
        CMP      R0,#+3
        BGE.N    ??Synchro_19
        CMP      R0,R2
        IT      GE 
        STRHGE   R5,[R4, #+34]
//  485   
//  486   A_Vpp = A_Max - A_Min;
??Synchro_19:
        LDRSH    R0,[R4, #+22]
        LDRSH    R1,[R4, #+24]
        SUBS     R0,R0,R1
//  487   B_Vpp = B_Max - B_Min;
        LDRSH    R1,[R4, #+34]
        STRH     R0,[R4, #+20]
        LDRSH    R0,[R4, #+32]
        SUBS     R0,R0,R1
        STRH     R0,[R4, #+30]
//  488   
//  489   
//  490 }  
        POP      {R4-R11,PC}      ;; return
        DATA
??Synchro_5:
        DC32     0xfff
        DC32     B_Rms
        CFI EndBlock cfiBlock8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable16:
        DC32     V

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable17:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable18:
        DC32     TrackBuff

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable19:
        DC32     Wait_Cnt

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Set??rT:
        LDR.N    R3,??Subroutine0_0  ;; __Set
        BX       R3
        DATA
??Subroutine0_0:
        DC32     __Set
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Clear_Screen??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Clear_Screen
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Clear_Screen
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine2_0  ;; Delayms
        BX       R3
        DATA
??Subroutine2_0:
        DC32     Delayms
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Ref_Wave??rT:
        LDR.N    R3,??Subroutine3_0  ;; Get_Ref_Wave
        BX       R3
        DATA
??Subroutine3_0:
        DC32     Get_Ref_Wave
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI NoFunction
        THUMB
??rT??div32_t:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine4_0  ;; ??div32_t
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine4_0:
        DC32     ??div32_t
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Read_FIFO??rT:
        LDR.N    R3,??Subroutine5_0  ;; __Read_FIFO
        BX       R3
        DATA
??Subroutine5_0:
        DC32     __Read_FIFO
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Get??rT:
        LDR.N    R3,??Subroutine6_0  ;; __Get
        BX       R3
        DATA
??Subroutine6_0:
        DC32     __Get
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??Draw_Window??rT:
        LDR.N    R3,??Subroutine7_0  ;; Draw_Window
        BX       R3
        DATA
??Subroutine7_0:
        DC32     Draw_Window
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon0
        CFI NoFunction
        THUMB
??Int_sqrt??rT:
        LDR.N    R3,??Subroutine8_0  ;; Int_sqrt
        BX       R3
        DATA
??Subroutine8_0:
        DC32     Int_sqrt
        CFI EndBlock cfiBlock17

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for V>`:
        DATA
        DC8 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Ch>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_max>`:
        DC8 0
`?<Initializer for b_max>`:
        DC8 0
`?<Initializer for a_min>`:
        DC8 0
`?<Initializer for b_min>`:
        DC8 0
`?<Initializer for Interlace>`:
        DC8 0
        DC8 0
`?<Initializer for A_Vdc>`:
        DC8 0, 0
`?<Initializer for A_Vpp>`:
        DC8 0, 0
`?<Initializer for A_Max>`:
        DC8 0, 0
`?<Initializer for A_Min>`:
        DC8 0, 0
`?<Initializer for A_Rms>`:
        DC8 0, 0
`?<Initializer for B_Vdc>`:
        DC8 0, 0
`?<Initializer for B_Vpp>`:
        DC8 0, 0
`?<Initializer for B_Max>`:
        DC8 0, 0
`?<Initializer for B_Min>`:
        DC8 0, 0
`?<Initializer for JumpCnt>`:
        DC8 0, 0
`?<Initializer for n>`:
        DC8 0, 0
`?<Initializer for Ka2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Kb2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Kab>`:
        DC8 0
        DC8 0, 0, 0
`?<Initializer for Ka1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Kb1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for a_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for Tmp>`:
        DC8 0, 0, 0, 0
`?<Initializer for X_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Full>`:
        DATA
        DC8 1

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for Ka3>`:
        DATA
        DC16 256
`?<Initializer for Kb3>`:
        DC16 256
`?<Initializer for G_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for D_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 179, 39999, 50
        DC8 " 20Hz "
        DC8 0
        DC16 179, 19999, 50
        DC8 " 50Hz "
        DC8 0
        DC16 179, 7999, 50
        DC8 "!100Hz!"
        DC16 179, 3999, 50
        DC8 "!200Hz!"
        DC16 179, 1999, 50
        DC8 "!500Hz!"
        DC16 179, 799, 50
        DC8 " 1KHz "
        DC8 0
        DC16 179, 399, 50
        DC8 " 2KHz "
        DC8 0
        DC16 179, 199, 50
        DC8 " 5KHz "
        DC8 0
        DC16 17, 799, 50
        DC8 "!10KHz!"
        DC16 17, 399, 50
        DC8 "!20KHz!"
        DC16 17, 199, 50
        DC8 "!50KHz!"
        DC16 0, 1439, 50
        DC8 "100KHz"
        DC8 0
        DC16 0, 719, 50
        DC8 "200KHz"
        DC8 0
        DC16 0, 359, 50
        DC8 "500KHz"
        DC8 0
        DC16 0, 143, 50
        DC8 " 1MHz "
        DC8 0
        DC16 0, 71, 50
        DC8 " 2MHz "
        DC8 0
        DC16 0, 35, 50
        DC8 " 4MHz "
        DC8 0
        DC16 0, 17, 50
        DC8 " 6MHz "
        DC8 0
        DC16 0, 11, 50
        DC8 " 8MHz "
        DC8 0
        DC16 0, 8, 50

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for A_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 19, 9999
        DC8 " 20Hz "
        DC8 0
        DC16 19, 4999
        DC8 " 50Hz "
        DC8 0
        DC16 19, 1999
        DC8 "!100Hz!"
        DC16 19, 999
        DC8 "!200Hz!"
        DC16 19, 499
        DC8 "!500Hz!"
        DC16 19, 199
        DC8 " 1KHz "
        DC8 0
        DC16 19, 99
        DC8 " 2KHz "
        DC8 0
        DC16 19, 49
        DC8 " 5KHz "
        DC8 0
        DC16 19, 19
        DC8 "!10KHz!"
        DC16 19, 9
        DC8 "!20KHz!"
        DC16 19, 4
`?<Initializer for SIN_DATA>`:
        DC16 0, 39, 142, 304, 521, 785, 1089, 1423, 1776, 2138, 2496, 2841
        DC16 3161, 3446, 3688, 3878, 4011, 4083, 4095, 4055, 3952, 3790, 3573
        DC16 3309, 3005, 2671, 2318, 1956, 1598, 1253, 933, 648, 406, 216, 83
        DC16 11
`?<Initializer for TRG_DATA>`:
        DC16 0, 227, 454, 682, 909, 1137, 1364, 1592, 1819, 2047, 2274, 2502
        DC16 2729, 2957, 3184, 3412, 3639, 3867, 4094, 3867, 3639, 3412, 3184
        DC16 2957, 2729, 2502, 2274, 2047, 1819, 1592, 1364, 1137, 909, 682
        DC16 454, 227
`?<Initializer for SAW_DATA>`:
        DC16 0, 117, 234, 351, 468, 585, 702, 819, 936, 1053, 1170, 1287, 1404
        DC16 1521, 1638, 1755, 1872, 1989, 2106, 2223, 2340, 2457, 2574, 2691
        DC16 2808, 2925, 3042, 3159, 3276, 3393, 3510, 3627, 3744, 3861, 3978
        DC16 4095

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
//  491 /******************************** END OF FILE *********************************/
// 
//  3 320 bytes in segment CODE
//     56 bytes in segment DATA_C
//    769 bytes in segment DATA_I
//    769 bytes in segment DATA_ID
// 17 594 bytes in segment DATA_Z
//     24 bytes in segment INITTAB
// 
//  3 240 bytes of CODE  memory (+ 104 bytes shared)
//    825 bytes of CONST memory
// 18 363 bytes of DATA  memory
//
//Errors: none
//Warnings: none
