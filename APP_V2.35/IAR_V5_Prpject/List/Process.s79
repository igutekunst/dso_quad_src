//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   30/Mar/2011  15:20:36 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203_MiniDSO\SFW\APP_V2.31\source\Proces /
//                       s.c                                                 /
//    Command line    =  D:\Design\DS203_MiniDSO\SFW\APP_V2.31\source\Proces /
//                       s.c -lA D:\Design\DS203_MiniDSO\SFW\APP_V2.31\IAR_V /
//                       4_Prpject\List\ -o D:\Design\DS203_MiniDSO\SFW\APP_ /
//                       V2.31\IAR_V4_Prpject\Obj\ -s9 --debug --cpu_mode    /
//                       thumb --endian little --cpu cortex-M3               /
//                       --stack_align 4 --fpu None --dlib_config            /
//                       "C:\Program Files\IAR Systems\Embedded Workbench    /
//                       4.0 Evaluation\arm\LIB\dl7mptnnl8f.h" -I            /
//                       D:\Design\DS203_MiniDSO\SFW\APP_V2.31\IAR_V4_Prpjec /
//                       t\..\..\FWLib\inc\ -I D:\Design\DS203_MiniDSO\SFW\A /
//                       PP_V2.31\IAR_V4_Prpject\..\..\USBLib\inc\ -I        /
//                       D:\Design\DS203_MiniDSO\SFW\APP_V2.31\IAR_V4_Prpjec /
//                       t\..\include\ -I "C:\Program Files\IAR              /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\INC\" --inline_threshold=16          /
//    List file       =  D:\Design\DS203_MiniDSO\SFW\APP_V2.31\IAR_V4_Prpjec /
//                       t\List\Process.s79                                  /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Process

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        EXTERN ??div32_t

        PUBWEAK `?*?DATA_ID`
??DataTable0 EQU 0
??DataTable2 EQU 0
??DataTable4 EQU 0
??DataTable9 EQU 0
        MULTWEAK ??Delayms??rT
        MULTWEAK ??Draw_Window??rT
        MULTWEAK ??Get_Ref_Wave??rT
        MULTWEAK ??Int_sqrt??rT
        MULTWEAK ??__Clear_Screen??rT
        MULTWEAK ??__Get??rT
        MULTWEAK ??__Read_FIFO??rT
        MULTWEAK ??__Set??rT
        MULTWEAK ??rT??div32_t
        PUBWEAK ?init?tab?DATA_I
        PUBWEAK ?init?tab?DATA_Z
        PUBLIC A_Max
        PUBLIC A_Min
        PUBLIC A_Rms
        PUBLIC A_Tab
        PUBLIC A_Vdc
        PUBLIC A_Vpp
        PUBLIC App_init
        FUNCTION App_init,0203H
        LOCFRAME CSTACK, 20, STACK
        PUBLIC B_Max
        PUBLIC B_Min
        PUBLIC B_Rms
        PUBLIC B_Vdc
        PUBLIC B_Vpp
        PUBLIC CH_D_Data
        FUNCTION CH_D_Data,0203H
        LOCFRAME CSTACK, 44, STACK
        PUBLIC Ch
        PUBLIC D_Tab
        PUBLIC DataBuf
        PUBLIC Full
        PUBLIC G_Attr
        PUBLIC Interlace
        PUBLIC JumpCnt
        PUBLIC Ka1
        PUBLIC Ka2
        PUBLIC Ka3
        PUBLIC Kb1
        PUBLIC Kb2
        PUBLIC Kb3
        PUBLIC Process
        FUNCTION Process,0203H
        LOCFRAME CSTACK, 60, STACK
        PUBLIC SAW_DATA
        PUBLIC SIN_DATA
        PUBLIC Synchro
        FUNCTION Synchro,0203H
        LOCFRAME CSTACK, 36, STACK
        PUBLIC TRG_DATA
        PUBLIC T_Attr
        PUBLIC Tmp
        PUBLIC TrackBuff
        PUBLIC Update_Base
        FUNCTION Update_Base,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Output
        FUNCTION Update_Output,0203H
        LOCFRAME CSTACK, 16, STACK
        PUBLIC Update_Range
        FUNCTION Update_Range,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Update_Trig
        FUNCTION Update_Trig,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC V
        PUBLIC View_init
        FUNCTION View_init,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC Wait
        PUBLIC X_Attr
        PUBLIC Y_Attr
        PUBLIC a_Avg
        PUBLIC a_Ssq
        PUBLIC a_max
        PUBLIC a_min
        PUBLIC b_Avg
        PUBLIC b_Ssq
        PUBLIC b_max
        PUBLIC b_min
        PUBLIC n
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
Delayms             SYMBOL "Delayms"
Draw_Window         SYMBOL "Draw_Window"
Get_Ref_Wave        SYMBOL "Get_Ref_Wave"
Int_sqrt            SYMBOL "Int_sqrt"
__Clear_Screen      SYMBOL "__Clear_Screen"
__Get               SYMBOL "__Get"
__Read_FIFO         SYMBOL "__Read_FIFO"
__Set               SYMBOL "__Set"
??Delayms??rT       SYMBOL "??rT", Delayms
??Draw_Window??rT   SYMBOL "??rT", Draw_Window
??Get_Ref_Wave??rT  SYMBOL "??rT", Get_Ref_Wave
??Int_sqrt??rT      SYMBOL "??rT", Int_sqrt
??__Clear_Screen??rT SYMBOL "??rT", __Clear_Screen
??__Get??rT         SYMBOL "??rT", __Get
??__Read_FIFO??rT   SYMBOL "??rT", __Read_FIFO
??__Set??rT         SYMBOL "??rT", __Set

        EXTERN Current
        EXTERN Delayms
        FUNCTION Delayms,0202H
        EXTERN Draw_Window
        FUNCTION Draw_Window,0202H
        EXTERN FileBuff
        EXTERN Get_Ref_Wave
        FUNCTION Get_Ref_Wave,0202H
        EXTERN Int_sqrt
        FUNCTION Int_sqrt,0202H
        EXTERN Meter
        EXTERN PD_Cnt
        EXTERN Title
        EXTERN Update
        EXTERN V_Trigg
        EXTERN Wait_Cnt
        EXTERN __Clear_Screen
        FUNCTION __Clear_Screen,0202H
        EXTERN __Get
        FUNCTION __Get,0202H
        EXTERN __Read_FIFO
        FUNCTION __Read_FIFO,0202H
        EXTERN __Set
        FUNCTION __Set,0202H

// D:\Design\DS203_MiniDSO\SFW\APP_V2.31\source\Process.c
//    1 /******************** (C) COPYRIGHT 2009 e-Design Co.,Ltd. *********************
//    2  File Name : Process.c       
//    3  Version   : DS203_APP Ver 2.3x                                  Author : bure
//    4 *******************************************************************************/
//    5 #include "Interrupt.h"
//    6 #include "Function.h"
//    7 #include "Process.h"
//    8 #include "Draw.h"
//    9 #include "Menu.h"
//   10 #include "BIOS.h"
//   11 #include "File.h"
//   12 
//   13 u32 a_Avg, b_Avg, a_Ssq, b_Ssq;            // 统计用中间变量
//   14 u8  a_max, b_max, a_min, b_min;            // 统计用中间变量
//   15 s16 A_Vdc, A_Vpp, A_Max, A_Min, A_Rms;     // 计量结果

        RSEG DATA_Z:DATA:SORT:NOROOT(1)
//   16 s16 B_Vdc, B_Vpp, B_Max, B_Min, B_Rms;     
B_Rms:
        DS8 2
//   17 u8  Ch[4], V[8];
//   18 s32 Tmp;
//   19 
//   20 u16  JumpCnt, n;
//   21 u8   Full=1, Interlace;
//   22 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
//   23 uc16 Wait[27]= {1000, 500, 200, 100, 50, 20, 10, 5, 2, 2,   
Wait:
        DATA
        DC16 1000, 500, 200, 100, 50, 20, 10, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC16 2, 2, 2, 2, 2, 2, 2, 2, 2
        DC8 0, 0
//   24                 2,      2,   2,   2,  2,  2,  2, 2, 2, 2,    
//   25                 2,      2,   2,   2,  2,  2,  2 };
//   26                      

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   27 Y_attr *Y_Attr; 
Y_Attr:
        DS8 4
//   28 X_attr *X_Attr; 
//   29 G_attr *G_Attr; 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   30 T_attr *T_Attr; 
T_Attr:
        DS8 4
//   31 

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   32 u32  DataBuf[4096];
DataBuf:
        DS8 16384

        RSEG DATA_Z:DATA:SORT:NOROOT(2)
//   33 u8  TrackBuff  [X_SIZE * 4];         // 曲线轨迹缓存：i+0,i+1,i+2,i+3,分别存放1～4号轨迹数据
TrackBuff:
        DS8 1200

        RSEG DATA_I:DATA:SORT:NOROOT(2)
V:
        DS8 8
        REQUIRE `?<Initializer for V>`
Ch:
        DS8 4
        REQUIRE `?<Initializer for Ch>`
a_max:
        DS8 1
        REQUIRE `?<Initializer for a_max>`
b_max:
        DS8 1
        REQUIRE `?<Initializer for b_max>`
a_min:
        DS8 1
        REQUIRE `?<Initializer for a_min>`
b_min:
        DS8 1
        REQUIRE `?<Initializer for b_min>`
Interlace:
        DS8 1
        REQUIRE `?<Initializer for Interlace>`
        DS8 1
A_Vdc:
        DS8 2
        REQUIRE `?<Initializer for A_Vdc>`
A_Vpp:
        DS8 2
        REQUIRE `?<Initializer for A_Vpp>`
A_Max:
        DS8 2
        REQUIRE `?<Initializer for A_Max>`
A_Min:
        DS8 2
        REQUIRE `?<Initializer for A_Min>`
A_Rms:
        DS8 2
        REQUIRE `?<Initializer for A_Rms>`
B_Vdc:
        DS8 2
        REQUIRE `?<Initializer for B_Vdc>`
B_Vpp:
        DS8 2
        REQUIRE `?<Initializer for B_Vpp>`
B_Max:
        DS8 2
        REQUIRE `?<Initializer for B_Max>`
B_Min:
        DS8 2
        REQUIRE `?<Initializer for B_Min>`
JumpCnt:
        DS8 2
        REQUIRE `?<Initializer for JumpCnt>`
n:
        DS8 2
        REQUIRE `?<Initializer for n>`
//   34 
//   35 s8  Ka1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // A通道零点误差校正系数
//   36 s8  Kb1[10] ={   0,    0,    0,    0,    0,    0,    0,    0,    0,    0}; // B通道零点误差校正系数
//   37 u16 Ka2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // A通道增益误差校正系数
Ka2:
        DS8 20
        REQUIRE `?<Initializer for Ka2>`
//   38 u16 Kb2[10] ={1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024}; // B通道增益误差校正系数
Kb2:
        DS8 20
        REQUIRE `?<Initializer for Kb2>`
Ka1:
        DS8 12
        REQUIRE `?<Initializer for Ka1>`
Kb1:
        DS8 12
        REQUIRE `?<Initializer for Kb1>`
a_Avg:
        DS8 4
        REQUIRE `?<Initializer for a_Avg>`
b_Avg:
        DS8 4
        REQUIRE `?<Initializer for b_Avg>`
a_Ssq:
        DS8 4
        REQUIRE `?<Initializer for a_Ssq>`
b_Ssq:
        DS8 4
        REQUIRE `?<Initializer for b_Ssq>`
Tmp:
        DS8 4
        REQUIRE `?<Initializer for Tmp>`
X_Attr:
        DS8 4
        REQUIRE `?<Initializer for X_Attr>`

        RSEG DATA_I:DATA:SORT:NOROOT(0)
Full:
        DS8 1
        REQUIRE `?<Initializer for Full>`

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   39 u16 Ka3 = 256, Kb3 = 256;                                                // A B通道位移误差校正系数
Ka3:
        DS8 2
        REQUIRE `?<Initializer for Ka3>`
Kb3:
        DS8 2
        REQUIRE `?<Initializer for Kb3>`
G_Attr:
        DS8 4
        REQUIRE `?<Initializer for G_Attr>`
//   40 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   41 D_tab D_Tab[20] ={  // 脉冲波形输出驱动表, 基于72MHz主频
D_Tab:
        DS8 280
        REQUIRE `?<Initializer for D_Tab>`
//   42 //    STR      PSC     ARR       DUTY% 
//   43   {" 10Hz ",  180-1,  40000-1,     50},
//   44   {" 20Hz ",  180-1,  20000-1,     50},
//   45   {" 50Hz ",  180-1,   8000-1,     50},
//   46   {"!100Hz!", 180-1,   4000-1,     50},
//   47   {"!200Hz!", 180-1,   2000-1,     50},
//   48   {"!500Hz!", 180-1,    800-1,     50},
//   49   {" 1KHz ",  180-1,    400-1,     50},
//   50   {" 2KHz ",  180-1,    200-1,     50},
//   51   {" 5KHz ",   18-1,    800-1,     50},
//   52   {"!10KHz!",  18-1,    400-1,     50},
//   53   {"!20KHz!",  18-1,    200-1,     50},
//   54   {"!50KHz!",   1-1,   1440-1,     50},
//   55   {"100KHz",    1-1,    720-1,     50},
//   56   {"200KHz",    1-1,    360-1,     50},
//   57   {"500KHz",    1-1,    144-1,     50},
//   58   {" 1MHz ",    1-1,     72-1,     50},
//   59   {" 2MHz ",    1-1,     36-1,     50},
//   60   {" 4MHz ",    1-1,     18-1,     50},
//   61   {" 6MHz ",    1-1,     12-1,     50},
//   62   {" 8MHz ",    1-1,      9-1,     50}};
//   63 

        RSEG DATA_I:DATA:SORT:NOROOT(2)
//   64 A_tab A_Tab[11] ={ // 模拟波形输出驱动表, 基于72MHz主频, 每周期36点合成
A_Tab:
        DS8 132
        REQUIRE `?<Initializer for A_Tab>`
//   65 //    STR     PSC     ARR 
//   66   {" 10Hz ",  20-1,  10000-1},
//   67   {" 20Hz ",  20-1,   5000-1},
//   68   {" 50Hz ",  20-1,   2000-1},
//   69   {"!100Hz!", 20-1,   1000-1},
//   70   {"!200Hz!", 20-1,    500-1},
//   71   {"!500Hz!", 20-1,    200-1},
//   72   {" 1KHz ",  20-1,    100-1},
//   73   {" 2KHz ",  20-1,     50-1},
//   74   {" 5KHz ",  20-1,     20-1},
//   75   {"!10KHz!", 20-1,     10-1},
//   76   {"!20KHz!", 20-1,      5-1}};
//   77 
//   78 u16 SIN_DATA[36] =  // Sine wave data                                                                                                 //         
SIN_DATA:
        DS8 72
        REQUIRE `?<Initializer for SIN_DATA>`
//   79   {0x000,0x027,0x08E,0x130,0x209,0x311,0x441,0x58F,0x6F0,    // 90
//   80    0x85A,0x9C0,0xB19,0xC59,0xD76,0xE68,0xF26,0xFAB,0xFF3,    // 180
//   81    0xFFF,0xFD7,0xF70,0xECE,0xDF5,0xCED,0xBBD,0xA6F,0x90E,    // 270
//   82    0x7A4,0x63E,0x4E5,0x3A5,0x288,0x196,0x0D8,0x053,0x00B,};  // 360   
//   83 
//   84 u16 TRG_DATA[36] =  // triangle wave data
TRG_DATA:
        DS8 72
        REQUIRE `?<Initializer for TRG_DATA>`
//   85   {0x000,0x0E3,0x1C6,0x2AA,0x38D,0x471,0x554,0x638,0x71B,    // 90
//   86    0x7FF,0x8E2,0x9C6,0xAA9,0xB8D,0xC70,0xD54,0xE37,0xF1B,    // 180
//   87    0xFFE,0xF1B,0xE37,0xD54,0xC70,0xB8D,0xAA9,0x9C6,0x8E2,    // 270
//   88    0x7FF,0x71B,0x638,0x554,0x471,0x38D,0x2AA,0x1C6,0x0E3};   // 360			
//   89          
//   90 u16 SAW_DATA[36] =  // Sawtooth wave data                                                                                             //         
SAW_DATA:
        DS8 72
        REQUIRE `?<Initializer for SAW_DATA>`
//   91   {0x000,0x075,0x0EA,0x15F,0x1D4,0x249,0x2BE,0x333,0x3A8,    // 90
//   92    0x41D,0x492,0x507,0x57C,0x5F1,0x666,0x6DB,0x750,0x7C5,    // 180
//   93    0x83A,0x8AF,0x924,0x999,0xA0E,0xA83,0xAF8,0xB6D,0xBE2,    // 270
//   94    0xC57,0xCCC,0xD41,0xDB6,0xE2B,0xEA0,0xF15,0xF8A,0xFFF};   // 360    
//   95 
//   96 
//   97 /*******************************************************************************
//   98  App_init: 显示窗口波形数据初始化
//   99 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function App_init
        THUMB
//  100 void App_init(void)
//  101 { 
App_init:
        PUSH     {R4,R5,R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  102   u16 i, j;
//  103   __Set(ADC_CTRL, EN );       
        MOVS     R1,#+1
//  104   __Set(STANDBY, DN);          // 退出省电状态
//  105   __Clear_Screen(BLACK);       // 清屏幕
//  106   Delayms(20); 
//  107   __Set(FIFO_CLR, W_PTR); 
//  108   for(i=0; i<13; i++) for(j=0; j<4; j++) Title[i][j].Flag |= UPDAT;
        LDR.N    R4,??DataTable3  ;; Title
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R0,#+20
        _BLF     __Set,??__Set??rT
        MOVS     R0,#+0
        _BLF     __Clear_Screen,??__Clear_Screen??rT
        MOVS     R0,#+20
        _BLF     Delayms,??Delayms??rT
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOVS     R7,#+80
??App_init_0:
        MOVS     R3,#+0
??App_init_1:
        MOVS     R5,R2
        MOVS     R0,#+20
        MLA      R5,R5,R7,R4
        MLA      R0,R3,R0,R5
        ADDS     R3,R3,#+1
        UXTH     R3,R3
        LDRB     R5,[R0, #+18]
        ORRS     R5,R5,#0x2
        STRB     R5,[R0, #+18]
        CMP      R3,#+4
        BCC.N    ??App_init_1
        ADDS     R2,R2,#+1
        UXTH     R2,R2
        CMP      R2,#+13
        BCC.N    ??App_init_0
//  109   for(i=0; i<9; i++)                     Meter[i].Flag    |= UPDAT;
        LDR.N    R5,??App_init_2  ;; Meter
        MOVS     R0,#+0
??App_init_3:
        MOVS     R2,R0
        MOVS     R3,#+12
        ADDS     R0,R0,#+1
        MLA      R2,R2,R3,R5
        UXTH     R0,R0
        LDRB     R3,[R2, #+11]
        ORRS     R3,R3,#0x2
        STRB     R3,[R2, #+11]
        CMP      R0,#+9
        BCC.N    ??App_init_3
//  110   if(Current != FILE) {
        LDR.N    R0,??App_init_2+0x4  ;; Current
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BEQ.N    ??App_init_4
//  111     Title[FILE][0].Flag &= !UPDAT;
        ADDW     R0,R4,#+738
//  112     Title[FILE][1].Flag &= !UPDAT;
//  113     Title[FILE][3].Flag &= !UPDAT;
        STRB     R1,[R4, #+798]
        STRB     R1,[R0, #+0]
        STRB     R1,[R0, #+20]
//  114   }  
//  115   PD_Cnt = 600;
??App_init_4:
        LDR.N    R0,??App_init_2+0x8  ;; PD_Cnt
        MOVS     R1,#+600
        STRH     R1,[R0, #+0]
//  116   Update = 1;                  // 返回后恢复原来的档位设置
        LDR.N    R0,??App_init_2+0xC  ;; Update
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  117 }
        POP      {R4,R5,R7,PC}
        DATA
??App_init_2:
        DC32     Meter
        DC32     Current
        DC32     PD_Cnt
        DC32     Update
        CFI EndBlock cfiBlock0
//  118 /*******************************************************************************
//  119  View_init: 显示窗口波形数据初始化
//  120 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function View_init
        THUMB
//  121 void View_init(void)
//  122 { 
View_init:
        PUSH     {R4,R6-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  123   u16 i, j = 0, k = 0;
        MOVS     R6,#+0
//  124   for(i = 0; i < X_SIZE * 4; i += 4){
        MOVS     R4,#+0
        MOV      R8,R6
        B.N      ??View_init_0
//  125     TrackBuff[i] = 160;
??View_init_1:
        LDR.N    R0,??DataTable1  ;; TrackBuff
        ADDS     R7,R0,R4
        MOVS     R0,#+160
        STRB     R0,[R7, #+0]
//  126     TrackBuff[i+1] = Get_Ref_Wave(i/4);
        LSRS     R0,R4,#+2
        UXTH     R0,R0
        _BLF     Get_Ref_Wave,??Get_Ref_Wave??rT
        STRB     R0,[R7, #+1]
//  127     if((i%160)==0) j = 1 - j;
        MOVS     R0,R4
        MOVS     R1,#+160
        _BLF     ??div32_t,??rT??div32_t
        CBNZ     R0,??View_init_2
        MOVS     R0,#+1
        MOV      R1,R8
        SUBS     R0,R0,R1
        UXTH     R0,R0
        MOV      R8,R0
//  128     TrackBuff[i+2] = 60 + (j * 17);
??View_init_2:
        MOVS     R0,#+17
        MUL      R0,R8,R0
        ADDS     R0,R0,#+60
        STRB     R0,[R7, #+2]
//  129     if((i%64)==0) k = 1 - k;
        LSRS     R0,R4,#+6
        UXTH     R0,R0
        SUBS     R0,R4,R0, LSL #+6
        ITTT    EQ 
        MOVEQ    R0,#+1
        SUBEQ    R6,R0,R6
        UXTHEQ   R6,R6
//  130     TrackBuff[i+3] = 20 + (k * 17);
        MOVS     R0,#+17
//  131   }
        ADDS     R4,R4,#+4
        MULS     R0,R6,R0
        ADDS     R0,R0,#+20
        STRB     R0,[R7, #+3]
        UXTH     R4,R4
??View_init_0:
        MOVS     R1,#+1200
        CMP      R4,R1
        BCC.N    ??View_init_1
//  132 }
        POP      {R4,R6-R8,PC}
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     TrackBuff
//  133 /*******************************************************************************
//  134  Update_Range: 
//  135 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function Update_Range
        THUMB
//  136 void Update_Range(void) 
//  137 {
Update_Range:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  138   Interlace = 0;
        LDR.N    R4,??DataTable8  ;; V
//  139   __Set(ADC_MODE, SEPARATE);                        // Set Separate mode
//  140   __Set(CH_A_COUPLE, Title[TRACK1][COUPLE].Value);
        LDR.N    R5,??DataTable3  ;; Title
//  141   __Set(CH_A_RANGE,  Title[TRACK1][RANGE].Value);
//  142   __Set(CH_A_OFFSET, (Ka3 * Title[TRACK1][POSI].Value)/256);
        LDR.N    R7,??Update_Range_0  ;; Ka3
        MOVS     R0,#+0
        MOVS     R6,R5
        ADDS     R6,R6,#+16
        STRB     R0,[R4, #+16]
        MOVS     R1,#+0
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+20]
        MOVS     R0,#+9
//  143   if(_1_source == HIDE){
        ADDW     R8,R5,#+336
        _BLF     __Set,??__Set??rT
        LDRSH    R1,[R6, #+40]
        MOVS     R0,#+10
        _BLF     __Set,??__Set??rT
        LDRH     R0,[R7, #+0]
        LDRSH    R1,[R6, #+60]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+0
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R6, #+0]
        CBNZ     R0,??Update_Range_1
//  144     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_1
//  145       __Set(CH_A_RANGE, G_Attr[0].Yp_Max+1);        // A通道合并到B通道 
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+10
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  146       __Set(ADC_MODE, INTERLACE);                   // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  147       Interlace = 1;                      
        MOVS     R0,#+1
        STRB     R0,[R4, #+16]
//  148     }  
//  149   }
//  150   __Set(CH_B_COUPLE, Title[TRACK2][COUPLE].Value);
??Update_Range_1:
        LDRSH    R1,[R6, #+100]
        MOVS     R0,#+11
        _BLF     __Set,??__Set??rT
//  151   __Set(CH_B_RANGE,  Title[TRACK2][RANGE].Value);
        LDRSH    R1,[R6, #+120]
        MOVS     R0,#+12
        _BLF     __Set,??__Set??rT
//  152   __Set(CH_B_OFFSET, (Kb3 * Title[TRACK2][POSI].Value)/256);
        LDRH     R0,[R7, #+2]
        LDRSH    R1,[R5, #+156]
        MULS     R0,R1,R0
        ASRS     R1,R0,#+7
        ADDS     R0,R0,R1, LSR #+24
        ASRS     R1,R0,#+8
        MOVS     R0,#+1
        _BLF     __Set,??__Set??rT
//  153   if(_2_source == HIDE){
        LDRSH    R0,[R6, #+80]
        CBNZ     R0,??Update_Range_2
//  154     if(_T_base > 16){
        LDRSH    R0,[R8, #+100]
        CMP      R0,#+17
        BLT.N    ??Update_Range_2
//  155       __Set(CH_B_RANGE,  G_Attr[0].Yp_Max+1);      // B通道合并到A通道
        LDR      R0,[R7, #+4]
        LDRH     R1,[R0, #+4]
        MOVS     R0,#+12
        ADDS     R1,R1,#+1
        _BLF     __Set,??__Set??rT
//  156       __Set(ADC_MODE, INTERLACE);                  // Set Interlace mode
        MOVS     R1,#+1
        MOVS     R0,#+5
        _BLF     __Set,??__Set??rT
//  157       Interlace = 2;                        
        MOVS     R0,#+2
        STRB     R0,[R4, #+16]
//  158     }
//  159   } 
//  160   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);       // FIFO写指针复位
??Update_Range_2:
        LDRSH    R0,[R8, #+0]
        CBNZ     R0,??Update_Range_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  161 }
??Update_Range_3:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Range_0:
        DC32     Ka3
        CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     Title
//  162 /*******************************************************************************
//  163  Update_Base: 
//  164 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function Update_Base
        THUMB
//  165 void Update_Base(void) 
//  166 {
Update_Base:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  167   u16 i;
//  168   
//  169   __Set(ADC_CTRL, EN);       
//  170   i = Title[T_BASE][BASE].Value;
        LDR.N    R4,??Update_Base_0  ;; Title + 336
        MOVS     R1,#+1
//  171   __Set(T_BASE_PSC, X_Attr[i].PSC);
        LDR.N    R6,??DataTable8  ;; V
        MOVS     R0,#+36
        _BLF     __Set,??__Set??rT
        LDRSH    R5,[R4, #+100]
        MOVS     R0,#+20
        UXTH     R5,R5
        MULS     R5,R0,R5
        LDR      R0,[R6, #+124]
        ADDS     R0,R0,R5
        LDRSH    R1,[R0, #+8]
        MOVS     R0,#+7
        _BLF     __Set,??__Set??rT
//  172   __Set(T_BASE_ARR, X_Attr[i].ARR);
        LDR      R0,[R6, #+124]
        ADDS     R0,R0,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+8
        _BLF     __Set,??__Set??rT
//  173   Wait_Cnt = Wait[_T_base];
        LDR.N    R2,??DataTable5  ;; Wait
        LDR.N    R0,??DataTable6  ;; Wait_Cnt
        LDRSH    R1,[R4, #+100]
        LDRH     R1,[R2, R1, LSL #+1]
        STR      R1,[R0, #+0]
//  174   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Base_1
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  175 }
??Update_Base_1:
        POP      {R4-R6,PC}       ;; return
        DATA
??Update_Base_0:
        DC32     Title + 336
        CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     Wait_Cnt
//  176 /*******************************************************************************
//  177  Update_Output: 
//  178 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function Update_Output
        THUMB
//  179 void Update_Output(void) 
//  180 {
Update_Output:
        PUSH     {R4-R6,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R6 Frame(CFA, -8)
        CFI R5 Frame(CFA, -12)
        CFI R4 Frame(CFA, -16)
        CFI CFA R13+16
//  181   if(_Kind == SINE){
        LDR.N    R4,??Update_Output_0  ;; Title + 496
        LDR.N    R5,??Update_Output_0+0x4  ;; 0x40020450
        LDR.N    R6,??Update_Output_0+0x8  ;; A_Tab
        LDRSH    R0,[R4, #+0]
        CBNZ     R0,??Update_Output_1
//  182     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  183     (*((vu32 *)(0x40020400+0x50))) = (u32)&SIN_DATA[0];
        MOVS     R0,R6
        ADDS     R0,R0,#+132
        STR      R0,[R5, #+0]
//  184     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  185   }
//  186   if(_Kind == SAW){
??Update_Output_1:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+2
        BNE.N    ??Update_Output_2
//  187     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
//  188     (*((vu32 *)(0x40020400+0x50))) = (u32)&SAW_DATA[0];
        ADDW     R0,R6,#+276
        STR      R0,[R5, #+0]
//  189     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  190   }
//  191   if(_Kind == TRIANG){
??Update_Output_2:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Output_3
//  192     __Set(ANALOG_ARR, A_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+12
        MLA      R0,R0,R1,R6
//  193     (*((vu32 *)(0x40020400+0x50))) = (u32)&TRG_DATA[0];
        ADDS     R6,R6,#+204
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+13
        _BLF     __Set,??__Set??rT
        STR      R6,[R5, #+0]
//  194     __Set(ANALOG_CNT, 36);
        MOVS     R1,#+36
        MOVS     R0,#+15
        _BLF     __Set,??__Set??rT
//  195   }
//  196   if(_Kind == DIGI){
??Update_Output_3:
        LDRSH    R0,[R4, #+0]
        CMP      R0,#+3
        BNE.N    ??Update_Output_4
//  197     __Set(DIGTAL_PSC, D_Tab[_Frqn].PSC);
        LDRSH    R0,[R4, #+20]
        LDR.N    R5,??Update_Output_0+0xC  ;; D_Tab
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+8]
        MOVS     R0,#+16
        _BLF     __Set,??__Set??rT
//  198     __Set(DIGTAL_ARR, D_Tab[_Frqn].ARR);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R1,[R0, #+10]
        MOVS     R0,#+17
        _BLF     __Set,??__Set??rT
//  199     __Set(DIGTAL_CCR, (D_Tab[_Frqn].ARR+1)/2);
        LDRSH    R0,[R4, #+20]
        MOVS     R1,#+14
        MLA      R0,R0,R1,R5
        LDRH     R0,[R0, #+10]
        ADDS     R0,R0,#+1
        ADDS     R0,R0,R0, LSR #+31
        ASRS     R1,R0,#+1
        MOVS     R0,#+18
        _BLF     __Set,??__Set??rT
//  200   }
//  201 }
??Update_Output_4:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??Update_Output_0:
        DC32     Title + 496
        DC32     0x40020450
        DC32     A_Tab
        DC32     D_Tab
        CFI EndBlock cfiBlock4
//  202 /*******************************************************************************
//  203  Update_Trig: 
//  204 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function Update_Trig
        THUMB
//  205 void Update_Trig(void) 
//  206 { 
Update_Trig:
        PUSH     {R4-R8,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R8 Frame(CFA, -8)
        CFI R7 Frame(CFA, -12)
        CFI R6 Frame(CFA, -16)
        CFI R5 Frame(CFA, -20)
        CFI R4 Frame(CFA, -24)
        CFI CFA R13+24
//  207   if(T1 > T2)  __Set(T_THRESHOLD, (_T1 - _T2));  
//  208   else         __Set(T_THRESHOLD, (_T2 - _T1)); 
        LDR.N    R4,??DataTable7  ;; Title
//  209   __Set(TRIGG_MODE,  (_Tr_source<< 3)+_Tr_kind);
//  210   if(Title[TRIGG][SOURCE].Value == TRACK1){ 
        LDR.N    R6,??DataTable8  ;; V
        LDR.N    R7,??Update_Trig_0  ;; V_Trigg
        ADDW     R0,R4,#+816
        LDRSH    R1,[R0, #+20]
        LDRSH    R0,[R0, #+0]
        ADDW     R5,R4,#+576
        ADDW     R8,R4,#+56
        SUBS     R1,R1,R0
        MOVS     R0,#+34
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        LDRSH    R1,[R5, #+20]
        ADDS     R1,R1,R0, LSL #+3
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
        LDRSH    R0,[R5, #+0]
        CBNZ     R0,??Update_Trig_1
        LDRSH    R0,[R8, #+0]
        LDRSH    R1,[R7, #+0]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+80]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+40]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  211     __Set(V_THRESHOLD, (((_Vt1-Ka1[_A_Range])*1024)/Ka2[_A_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  212   }
//  213   if(Title[TRIGG][SOURCE].Value == TRACK2){ 
??Update_Trig_1:
        LDRSH    R0,[R5, #+0]
        CMP      R0,#+1
        BNE.N    ??Update_Trig_2
        LDRSH    R0,[R8, #+80]
        LDRSH    R1,[R7, #+4]
        ADDS     R2,R6,R0
        LDRSB    R2,[R2, #+92]
        ADDS     R0,R6,R0, LSL #+1
        LDRH     R0,[R0, #+60]
        SUBS     R1,R1,R2
        LSLS     R1,R1,#+10
        SDIV     R0,R1,R0
        UXTB     R1,R0
        MOVS     R0,#+33
//  214     __Set(V_THRESHOLD, (((_Vt2-Kb1[_B_Range])*1024)/Kb2[_B_Range])&0xFF); 
        _BLF     __Set,??__Set??rT
//  215   }
//  216   if(_Status == RUN) __Set(FIFO_CLR, W_PTR);      // FIFO写指针复位
??Update_Trig_2:
        LDRSH    R0,[R4, #+336]
        CBNZ     R0,??Update_Trig_3
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  217 }
??Update_Trig_3:
        POP      {R4-R8,PC}       ;; return
        DATA
??Update_Trig_0:
        DC32     V_Trigg
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     V
//  218 /*******************************************************************************
//  219  Process: 计算处理缓冲区数据 
//  220 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function Process
        THUMB
//  221 void Process(void)
//  222 { 
Process:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
//  223   s16 i, j, k;
//  224   
//  225   n= 0;
        LDR.N    R4,??Process_0   ;; V
        SUB      SP,SP,#+24
        CFI CFA R13+60
        MOVS     R0,#+0
//  226   k =((1024 -_Kp)* 150)/1024 + _X_posi.Value;  // 计算插值运算后窗口位置的修正值
        LDR      R3,[R4, #+124]
        MOV      R8,R0
        STRH     R0,[R4, #+38]
        LDR.N    R0,??Process_0+0x4  ;; Title
        MOVS     R2,#+20
        ADDW     R9,R0,#+436
        LDRSH    R1,[R9, #+0]
        MLA      R1,R1,R2,R3
        MOVS     R2,#+150
        LDRH     R1,[R1, #+14]
//  227   a_Avg =0; b_Avg =0; a_Ssq =0; b_Ssq =0;      // 统计用中间变量
        STR      R8,[R4, #+104]
        STR      R8,[R4, #+108]
        RSBS     R1,R1,#+1024
        STR      R8,[R4, #+112]
        MULS     R1,R2,R1
        ASRS     R2,R1,#+9
        STR      R8,[R4, #+116]
        ADDS     R1,R1,R2, LSR #+22
        LDRSH    R2,[R9, #+20]
        ASRS     R1,R1,#+10
        ADDS     R1,R1,R2
        SXTH     R1,R1
        STR      R1,[SP, #+12]
//  228   a_max =0; b_max =0; a_min =255; b_min =255;  // 统计用中间变量
        MOVS     R1,#+0
        STRH     R1,[R4, #+12]
        MOVS     R1,#+255
        STRB     R1,[R4, #+14]
        STRB     R1,[R4, #+15]
//  229 
//  230   if(Interlace == 0){                          // 独立采样模式
        MOVS     R1,R0
        ADDS     R0,R0,#+56
        MOV      R10,R0
        LDR.N    R0,??Process_0+0x8  ;; TrackBuff
        ADDS     R1,R1,#+236
        STR      R1,[SP, #+16]
        MOV      R11,R0
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BNE.W    ??Process_1
//  231     for(i=0; i <4096; i++){
        MOVS     R5,#+0
        B.N      ??Process_2
??Process_3:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+4096
        BGE.W    ??Process_4
//  232       if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
??Process_2:
        LDR.N    R0,??Process_0+0xC  ;; DataBuf
        ADDS     R6,R0,R5, LSL #+2
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_5
        LDRH     R0,[R4, #+36]
        CMP      R5,R0
        BNE.N    ??Process_5
        LDR      R1,[SP, #+16]
        LDRSH    R1,[R1, #+100]
        CBNZ     R1,??Process_5
//  233         JumpCnt++;
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+36]
//  234         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
//  235       }
//  236       Ch[A] = (DataBuf[i] & 0xFF );              
??Process_5:
        LDR      R2,[R6, #+0]
//  237       a_Avg += Ch[A];                           // 累计直流平均值              
        LDR      R0,[R4, #+104]
//  238       Tmp = Ch[A]-_1_posi;
        LDRSH    R3,[R10, #+20]
//  239       a_Ssq +=(Tmp * Tmp);                      // 统计平方和
        LDR      R6,[R4, #+112]
        STRB     R2,[R4, #+8]
        LDRB     R1,[R4, #+8]
        ADDS     R0,R0,R1
        STR      R0,[R4, #+104]
        MOVS     R0,R1
        SUBS     R3,R0,R3
        STR      R3,[R4, #+120]
        MLA      R3,R3,R3,R6
        STR      R3,[R4, #+112]
//  240       if(Ch[A] > a_max)  a_max = Ch[A];         // 统计最大值  
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
//  241       if(Ch[A] < a_min)  a_min = Ch[A];         // 统计最小值  
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
//  242   
//  243       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  244       b_Avg += Ch[B];                           // 累计直流平均值
//  245       Tmp = Ch[B]-_2_posi;
        LDRSH    R6,[R10, #+100]
//  246       b_Ssq +=(Tmp * Tmp);                      // 统计平方和
        LDR      R7,[R4, #+116]
        LSRS     R1,R2,#+8
        STRB     R1,[R4, #+9]
        LDRB     R3,[R4, #+9]
        LDR      R1,[R4, #+108]
        ADDS     R1,R1,R3
        STR      R1,[R4, #+108]
        MOVS     R1,R3
        SUBS     R6,R1,R6
        STR      R6,[R4, #+120]
        MLA      R6,R6,R6,R7
        STR      R6,[R4, #+116]
//  247       if(Ch[B] > b_max)  b_max = Ch[B];         // 统计最大值  
        LDRB     R6,[R4, #+13]
        CMP      R6,R3
        IT      CC 
        STRBCC   R3,[R4, #+13]
//  248       if(Ch[B] < b_min)  b_min = Ch[B];         // 统计最小值  
        LDRB     R6,[R4, #+15]
        CMP      R3,R6
        IT      CC 
        STRBCC   R3,[R4, #+15]
        LSRS     R3,R2,#+16
        MOVS     R6,#+1
        ANDS     R6,R6,R3
        STRB     R6,[R4, #+10]
//  249   
//  250       Ch[C] = ((DataBuf[i] >>16)& 1);
//  251       Ch[D] = ((DataBuf[i] >>17)& 1);
        LSRS     R2,R2,#+17
        MOVS     R3,#+1
        ANDS     R3,R3,R2
        STRB     R3,[R4, #+11]
//  252     
//  253       if((i > k)&&(n < 300-1)){                 // 指针到达指定窗口位置
        LDR      R2,[SP, #+12]
        CMP      R2,R5
        BGE.N    ??Process_3
        LDRH     R2,[R4, #+38]
        LDR.N    R3,??Process_6   ;; 0x12b
        CMP      R2,R3
        BCS.N    ??Process_3
//  254         j =i-k;
        LDR      R3,[SP, #+12]
        SUBS     R6,R5,R3
        LDRSH    R3,[R10, #+0]
        SXTH     R6,R6
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+40]
        MULS     R2,R0,R2
        ADDS     R0,R4,R3
        LDRSB    R0,[R0, #+80]
        ASRS     R3,R2,#+9
        ADDS     R2,R2,R3, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R0,R0,R2
        LDRSH    R2,[R10, #+80]
        STRB     R0,[R4, #+0]
        ADDS     R0,R4,R2, LSL #+1
        LDRH     R0,[R0, #+60]
        MULS     R0,R1,R0
        ADDS     R1,R4,R2
        LDRSB    R1,[R1, #+92]
        ASRS     R2,R0,#+9
        ADDS     R0,R0,R2, LSR #+22
        LDR      R2,[R4, #+124]
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+1]
        LDRSH    R0,[R9, #+0]
        MOVS     R1,#+20
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
        B.N      ??Process_7
//  255         V[A]  = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;      
//  256         V[B]  = Kb1[_B_Range] +(Kb2[_B_Range] *Ch[B])/1024;      //计算当前点的主值
//  257         while(j*1024 - n*_Kp > 0 ){
//  258           V[Ap]= V[A_]+((V[A]-V[A_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_A点的插值
//  259           TrackBuff[n*4 + TRACK1] = V[Ap];
//  260           
//  261           V[Bp]= V[B_]+((V[B]-V[B_])*((n *_Kp)-(j-1)*1024))/1024;  //计算当前CH_B点的插值
//  262           TrackBuff[n*4 + TRACK2] = V[Bp];
//  263           
//  264           Tmp = _3_posi + 20 * Ch[C];
//  265           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  266           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_8:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_9:
        STR      R0,[R4, #+120]
//  267           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  268           
//  269           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  270           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
//  271         V[A_] = V[A];  V[B_] = V[B];       
        LDRB     R0,[R4, #+0]
        STRH     R7,[R4, #+38]
        STRB     R0,[R4, #+2]
        LDRB     R0,[R4, #+1]
        STRB     R0,[R4, #+3]
??Process_7:
        LDR      R2,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LSLS     R1,R6,#+10
        LDRH     R2,[R2, #+14]
        MOVS     R0,R7
        MLS      R1,R0,R2,R1
        CMP      R1,#+1
        BLT.W    ??Process_3
        SUBS     R1,R6,#+1
        LSLS     R1,R1,#+10
        STR      R1,[SP, #+8]
        LDRB     R1,[R4, #+2]
        LDRB     R2,[R4, #+0]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+8]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        ADDS     R2,R11,R0, LSL #+2
        STRB     R1,[R4, #+4]
        STR      R2,[SP, #+0]
        STRB     R1,[R2, #+0]
        LDR      R3,[SP, #+4]
        LDRB     R1,[R4, #+3]
        LDRB     R2,[R4, #+1]
        LDRH     R3,[R3, #+14]
        SUBS     R2,R2,R1
        MULS     R0,R3,R0
        LDR      R3,[SP, #+8]
        SUBS     R0,R0,R3
        MULS     R2,R0,R2
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R1,R0
        STRB     R0,[R4, #+5]
        LDR      R1,[SP, #+0]
        MOVS     R2,#+20
        STRB     R0,[R1, #+1]
        LDR      R0,[SP, #+16]
        LDRB     R1,[R4, #+10]
        LDRSH    R0,[R0, #+0]
        MLA      R0,R1,R2,R0
        CMP      R0,#+200
        BLT.N    ??Process_8
        MOVS     R0,#+199
        B.N      ??Process_9
//  272         }
//  273       }
//  274     }
//  275   } else {                                      // 交替采样模式
//  276     for(i=0; i <4096; i++){
??Process_1:
        MOVS     R5,#+0
//  277       if((__Get(FIFO_EMPTY)==0)&&(i == JumpCnt)&&(_Status == RUN)){
??Process_10:
        LDR.N    R0,??Process_0+0xC  ;; DataBuf
        ADDS     R6,R0,R5, LSL #+2
        MOVS     R0,#+1
        _BLF     __Get,??__Get??rT
        CBNZ     R0,??Process_11
        LDRH     R0,[R4, #+36]
        CMP      R5,R0
        BNE.N    ??Process_11
        LDR      R1,[SP, #+16]
        LDRSH    R1,[R1, #+100]
        CBNZ     R1,??Process_11
//  278         JumpCnt++;
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+36]
//  279         DataBuf[i] = __Read_FIFO();             // 读入32位FIFO数据, 读后指针+1
        _BLF     __Read_FIFO,??__Read_FIFO??rT
        STR      R0,[R6, #+0]
//  280       }
//  281       Ch[A] = (DataBuf[i] & 0xFF );              
??Process_11:
        LDR      R2,[R6, #+0]
//  282       Ch[B] = ((DataBuf[i] >> 8) & 0xFF);       
//  283 
//  284       a_Avg += Ch[A]+Ch[B];                                   
        LDR      R3,[R4, #+104]
        STRB     R2,[R4, #+8]
//  285       b_Avg = a_Avg;                            // 累计直流平均值
//  286       
//  287       Tmp = Ch[A]-_1_posi;
//  288       a_Ssq +=(Tmp * Tmp);
        LDR      R7,[R4, #+112]
        LSRS     R0,R2,#+8
        STRB     R0,[R4, #+9]
        LDRB     R0,[R4, #+8]
        LDRB     R1,[R4, #+9]
        ADDS     R6,R0,R1
        ADDS     R3,R3,R6
        STR      R3,[R4, #+104]
        STR      R3,[R4, #+108]
        LDRSH    R3,[R10, #+20]
        SUBS     R6,R0,R3
        STR      R6,[R4, #+120]
        MLA      R6,R6,R6,R7
//  289       Tmp = Ch[B]-_1_posi;
        SUBS     R3,R1,R3
        STR      R3,[R4, #+120]
//  290       a_Ssq +=(Tmp * Tmp);                    
        MLA      R3,R3,R3,R6
        STR      R6,[R4, #+112]
        STR      R3,[R4, #+112]
//  291       b_Ssq  = a_Ssq;                           // 统计平方和
        STR      R3,[R4, #+116]
//  292       
//  293       if(Ch[A] > a_max)  a_max = Ch[A];          
        LDRB     R3,[R4, #+12]
        CMP      R3,R0
        IT      CC 
        STRBCC   R0,[R4, #+12]
//  294       if(Ch[B] > a_max)  a_max = Ch[B];         // 统计最大值 
        LDRB     R3,[R4, #+12]
        CMP      R3,R1
        IT      CC 
        STRBCC   R1,[R4, #+12]
//  295       b_max = a_max;
        LDRB     R3,[R4, #+12]
        STRB     R3,[R4, #+13]
//  296       
//  297       if(Ch[A] < a_min)  a_min = Ch[A];         
        LDRB     R3,[R4, #+14]
        CMP      R0,R3
        IT      CC 
        STRBCC   R0,[R4, #+14]
//  298       if(Ch[B] < a_min)  a_min = Ch[B];         // 统计最小值  
        LDRB     R3,[R4, #+14]
        CMP      R1,R3
        IT      CC 
        STRBCC   R1,[R4, #+14]
//  299       b_min = a_min;
        LDRB     R3,[R4, #+14]
        MOVS     R6,#+1
        STRB     R3,[R4, #+15]
        LSRS     R3,R2,#+16
        ANDS     R6,R6,R3
        STRB     R6,[R4, #+10]
//  300   
//  301       Ch[C] = ((DataBuf[i] >>16)& 1);
//  302       Ch[D] = ((DataBuf[i] >>17)& 1);
        LSRS     R2,R2,#+17
        MOVS     R3,#+1
        ANDS     R3,R3,R2
//  303     
//  304       if(_2_source == HIDE){                 // B通道合并到A通道时
        LDRSH    R2,[R10, #+40]
        STRB     R3,[R4, #+11]
        CBNZ     R2,??Process_12
        LDRSH    R3,[R10, #+0]
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+40]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+80]
        MULS     R0,R2,R0
        ASRS     R6,R0,#+9
//  305         V[A] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[A])/1024;        //计算当前第1点的主值
//  306         V[B] = Ka1[_A_Range] +(Ka2[_A_Range] *Ch[B])/1024;        //计算当前第2点的主值
        MULS     R2,R1,R2
        ADDS     R0,R0,R6, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+0]
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
        B.N      ??Process_13
//  307       } else {                            // A通道合并到B通道时
??Process_12:
        LDRSH    R3,[R10, #+80]
        ADDS     R2,R4,R3, LSL #+1
        LDRH     R2,[R2, #+60]
        ADDS     R3,R4,R3
        LDRSB    R3,[R3, #+92]
        MULS     R0,R2,R0
        ASRS     R6,R0,#+9
//  308         V[A] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[A])/1024;        //计算当前第1点的主值
//  309         V[B] = Kb1[_B_Range] +(Kb2[_B_Range] * Ch[B])/1024;        //计算当前第2点的主值
        MULS     R2,R1,R2
        ADDS     R0,R0,R6, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+0]
        ASRS     R0,R2,#+9
        ADDS     R0,R2,R0, LSR #+22
??Process_13:
        ASRS     R0,R0,#+10
        ADDS     R0,R3,R0
        STRB     R0,[R4, #+1]
//  310       }
//  311       if((i > k)&&(n < 300-1)){                 // 指针到达指定窗口位置
        LDR      R0,[SP, #+12]
        CMP      R0,R5
        BGE.W    ??Process_14
        LDRH     R0,[R4, #+38]
        LDR.N    R1,??Process_6   ;; 0x12b
        CMP      R0,R1
        BCS.W    ??Process_14
//  312         j =i - k;
        LDR      R1,[SP, #+12]
        LDRSH    R0,[R9, #+0]
        LDR      R2,[R4, #+124]
        SUBS     R6,R5,R1
        MOVS     R1,#+20
        SXTH     R6,R6
        MLA      R0,R0,R1,R2
        STR      R0,[SP, #+4]
        B.N      ??Process_15
//  313         while(j*1024 > n*_Kp){
//  314           V[Bp] =V[A_]+((V[B]-V[A_])*((n *_Kp)-(j-1)*1024))/1024;   //计算当前第2点的插值
//  315           TrackBuff[n*4 + TRACK1] = V[Bp];
//  316           TrackBuff[n*4 + TRACK2] = V[Bp];
//  317           Tmp = _3_posi + 20 * Ch[C];
//  318           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  319           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_16:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_17:
        STR      R0,[R4, #+120]
//  320           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  321           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  322           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
        STRH     R7,[R4, #+38]
??Process_15:
        LDR      R0,[SP, #+16]
        LDRB     R1,[R4, #+10]
        MOVS     R2,#+20
        LDRSH    R0,[R0, #+0]
        MLA      R0,R1,R2,R0
        SUBS     R1,R6,#+1
        LSLS     R1,R1,#+10
        STR      R0,[SP, #+8]
        LDRH     R7,[R4, #+38]
        STR      R1,[SP, #+20]
        LDR      R1,[SP, #+4]
        MOVS     R0,R7
        LDRH     R1,[R1, #+14]
        MULS     R1,R0,R1
        CMP      R1,R6, LSL #+10
        BGE.N    ??Process_18
        LDRB     R1,[R4, #+2]
        LDRB     R2,[R4, #+1]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+20]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        ADDS     R0,R11,R0, LSL #+2
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        STRB     R1,[R4, #+5]
        STR      R0,[SP, #+0]
        STRB     R1,[R0, #+0]
        LDR      R0,[SP, #+0]
        STRB     R1,[R0, #+1]
        LDR      R0,[SP, #+8]
        CMP      R0,#+200
        BLT.N    ??Process_16
        MOVS     R0,#+199
        B.N      ??Process_17
        DATA
??Process_0:
        DC32     V
        DC32     Title
        DC32     TrackBuff
        DC32     DataBuf
        THUMB
//  323         }
//  324         while(j*1024 > n*_Kp){
//  325           V[Ap] =V[B]+((V[A]-V[B])*((n *_Kp)-(j-1)*1024))/1024;   //计算当前第1点的插值
//  326           TrackBuff[n*4 + TRACK1] = V[Ap];
//  327           TrackBuff[n*4 + TRACK2] = V[Ap];
//  328           Tmp = _3_posi + 20 * Ch[C];
//  329           if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
//  330           else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??Process_19:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
??Process_20:
        STR      R0,[R4, #+120]
//  331           TrackBuff[n*4 + TRACK3] = Tmp;
        LDR      R1,[SP, #+0]
//  332           TrackBuff[n*4 + TRACK4] = CH_D_Data(); 
//  333           n++;
        ADDS     R7,R7,#+1
        STRB     R0,[R1, #+2]
        BL       CH_D_Data
        LDR      R1,[SP, #+0]
        STRB     R0,[R1, #+3]
        STRH     R7,[R4, #+38]
??Process_18:
        LDR      R1,[SP, #+4]
        LDRH     R7,[R4, #+38]
        LDRB     R2,[R4, #+0]
        LDRH     R1,[R1, #+14]
        MOVS     R0,R7
        MULS     R1,R0,R1
        CMP      R1,R6, LSL #+10
        BGE.N    ??Process_21
        LDRB     R1,[R4, #+1]
        SUBS     R3,R2,R1
        LDR      R2,[SP, #+4]
        MOV      R12,R3
        LDRH     R3,[R2, #+14]
        LDR      R2,[SP, #+20]
        MULS     R3,R0,R3
        SUBS     R2,R3,R2
        MOV      R3,R12
        ADDS     R0,R11,R0, LSL #+2
        MULS     R3,R2,R3
        ASRS     R2,R3,#+9
        ADDS     R2,R3,R2, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        STRB     R1,[R4, #+4]
        STR      R0,[SP, #+0]
        STRB     R1,[R0, #+0]
        LDR      R0,[SP, #+0]
        STRB     R1,[R0, #+1]
        LDR      R0,[SP, #+8]
        CMP      R0,#+200
        BLT.N    ??Process_19
        MOVS     R0,#+199
        B.N      ??Process_20
//  334         }
//  335         V[A_] = V[A]; 
??Process_21:
        STRB     R2,[R4, #+2]
//  336       }
//  337     }
??Process_14:
        ADDS     R5,R5,#+1
        SXTH     R5,R5
        CMP      R5,#+4096
        BLT.W    ??Process_10
//  338   }
//  339   for(i=0; i<4; i++){                                    // 消除屏幕端点连线
??Process_4:
        MOVS     R0,#+0
//  340     for(j=0; j<4; j++){
??Process_22:
        MOVS     R6,#+0
//  341       TrackBuff[(i+0)*4+ j]   = TrackBuff[(i+1)*4 + j];
??Process_23:
        ADDS     R1,R6,R0, LSL #+2
        ADD      R1,R1,R11
        LDRB     R2,[R1, #+4]
        STRB     R2,[R1, #+0]
//  342       TrackBuff[(299-i)*4+ j] = TrackBuff[(298-i)*4 + j];
        RSBS     R1,R0,#+0
        MOV      R2,R11
        ADDS     R1,R6,R1, LSL #+2
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+1192
        LDRB     R2,[R1, #+0]
//  343     }
        ADDS     R6,R6,#+1
        CMP      R6,#+4
        STRB     R2,[R1, #+4]
        BLT.N    ??Process_23
//  344   }
        ADDS     R0,R0,#+1
        CMP      R0,#+4
        BLT.N    ??Process_22
//  345 }
        ADD      SP,SP,#+24
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??Process_6:
        DC32     0x12b
        CFI EndBlock cfiBlock6
//  346 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function CH_D_Data
        THUMB
//  347 u8 CH_D_Data(void)  //计算生成CH_D通道的显示数据
//  348 {
//  349   s32 Tmp;
//  350   
//  351   switch (_4_source){  
CH_D_Data:
        LDR.N    R1,??DataTable11  ;; Title
        LDR.N    R3,??DataTable10  ;; V
        PUSH     {R4-R11}
        CFI R11 Frame(CFA, -4)
        CFI R10 Frame(CFA, -8)
        CFI R9 Frame(CFA, -12)
        CFI R8 Frame(CFA, -16)
        CFI R7 Frame(CFA, -20)
        CFI R6 Frame(CFA, -24)
        CFI R5 Frame(CFA, -28)
        CFI R4 Frame(CFA, -32)
        CFI CFA R13+32
        SUB      SP,SP,#+12
        CFI CFA R13+44
        LDRSH    R0,[R1, #+316]
        MOVS     R2,R1
        LDRSH    R9,[R1, #+156]!
        LDRSH    R1,[R1, #+100]
        MOV      R8,R3
        LDRB     R3,[R8, #+0]
        LDRB     R5,[R8, #+5]
        LDRB     R6,[R8, #+16]
        ADDS     R2,R2,#+16
        LDRSH    R4,[R2, #+60]
        ADDS     R5,R0,R5
        SUBS     R5,R5,R9
        STR      R5,[SP, #+8]
        LDRB     R5,[R8, #+4]
        ADDS     R3,R0,R3
        SUBS     R3,R3,R4
        ADDS     R5,R0,R5
        SUBS     R4,R5,R4
        LDRB     R5,[R8, #+11]
        STR      R4,[SP, #+4]
        LDR.N    R4,??CH_D_Data_1  ;; FileBuff
        SUBS     R1,R1,#+2
        MOV      R10,R4
        LDRH     R4,[R8, #+38]
        ADDS     R11,R4,R10
        LDRB     R4,[R8, #+1]
        CMP      R1,#+7
        STR      R4,[SP, #+0]
        LDRSH    R4,[R2, #+80]
        LDRSH    R2,[R2, #+0]
        BHI.N    ??CH_D_Data_2
        TBB      [PC, R1]
        DATA
??CH_D_Data_0:
        DC8      +4,+16,+26,+26
        DC8      +33,+40,+45,+52
        THUMB
//  352   case A_add_B:
//  353     if(Interlace == 0){                          // 独立采样模式
??CH_D_Data_3:
        CBNZ     R6,??CH_D_Data_4
//  354       Tmp = _4_posi +(V[A]-_1_posi)+(V[B]-_2_posi);
        LDR      R0,[SP, #+0]
        ADDS     R0,R3,R0
        SUBS     R0,R0,R9
        B.N      ??CH_D_Data_5
//  355     } else {                                     // 交替采样模式
//  356       Tmp = _4_posi;
//  357       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_4:
        CBZ      R2,??CH_D_Data_6
        LDR      R0,[SP, #+4]
//  358       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_6:
        CMP      R4,#+0
        BEQ.N    ??CH_D_Data_5
??CH_D_Data_7:
        LDR      R0,[SP, #+8]
        B.N      ??CH_D_Data_5
//  359     } break;
//  360   case A_sub_B:
//  361     if(Interlace == 0){                          // 独立采样模式
??CH_D_Data_8:
        CBNZ     R6,??CH_D_Data_9
//  362       Tmp = _4_posi +(V[A]-_1_posi)-(V[B]-_2_posi);  break;
        LDR      R0,[SP, #+0]
        SUBS     R0,R3,R0
        ADDS     R0,R9,R0
        B.N      ??CH_D_Data_5
//  363     } else {                                     // 交替采样模式
//  364       Tmp = _4_posi;
//  365       if(_1_source != HIDE)  Tmp = _4_posi +(V[Ap]-_1_posi);
??CH_D_Data_9:
        CBZ      R2,??CH_D_Data_10
        LDR      R0,[SP, #+4]
//  366       if(_2_source != HIDE)  Tmp = _4_posi +(V[Bp]-_2_posi);
??CH_D_Data_10:
        CBZ      R4,??CH_D_Data_5
        B.N      ??CH_D_Data_7
//  367     } break;
//  368   case C_and_D:
//  369     Tmp = _4_posi + 20 *(Ch[C] & Ch[D]);  break;
??CH_D_Data_11:
        LDRB     R1,[R8, #+10]
        ANDS     R5,R5,R1
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
        B.N      ??CH_D_Data_5
//  370   case C_or_D:
//  371     Tmp =  _4_posi + 20 *(Ch[C] & Ch[D]);  break;
//  372   case FILE1:
//  373     Tmp = FileBuff[n] - FileBuff[299] +_4_posi;  break;
??CH_D_Data_12:
        LDRB     R1,[R11, #+0]
        LDRB     R2,[R10, #+299]
??CH_D_Data_13:
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  374   case FILE2:
//  375     Tmp = FileBuff[n+300] - FileBuff[599] +_4_posi;  break;
??CH_D_Data_14:
        LDRB     R1,[R11, #+300]
        LDRB     R2,[R10, #+599]
        B.N      ??CH_D_Data_13
//  376   case FILE3:
//  377     Tmp = FileBuff[n+600] - FileBuff[899] +_4_posi;  break;
??CH_D_Data_15:
        LDRB     R1,[R11, #+600]
        LDRB     R2,[R10, #+899]
        SUBS     R1,R1,R2
        ADDS     R0,R1,R0
        B.N      ??CH_D_Data_5
//  378   case FILE4:
//  379     Tmp = FileBuff[n+900] - FileBuff[1199] +_4_posi;  break;
??CH_D_Data_16:
        LDRB     R1,[R11, #+900]
        LDRB     R2,[R10, #+1199]
        B.N      ??CH_D_Data_13
//  380   default:
//  381     Tmp = _4_posi + 20 * Ch[D];
??CH_D_Data_2:
        MOVS     R1,#+20
        MLA      R0,R5,R1,R0
//  382   }
//  383   if(Tmp >= Y_BASE+Y_SIZE)  Tmp = Y_BASE+Y_SIZE-1;
??CH_D_Data_5:
        CMP      R0,#+200
        BLT.N    ??CH_D_Data_17
        MOVS     R0,#+199
        B.N      ??CH_D_Data_18
//  384   else if(Tmp <= Y_BASE+1)  Tmp = Y_BASE+1;
??CH_D_Data_17:
        CMP      R0,#+2
        IT      LT 
        MOVLT    R0,#+1
//  385   return Tmp;
??CH_D_Data_18:
        UXTB     R0,R0
        ADD      SP,SP,#+12
        CFI CFA R13+32
        POP      {R4-R11}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??CH_D_Data_1:
        DC32     FileBuff
        CFI EndBlock cfiBlock7
//  386 }

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable10:
        DC32     V
//  387 /*******************************************************************************
//  388  Synchro: 扫描同步处理，按设定模式显示波形 
//  389 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function Synchro
        THUMB
//  390 void Synchro(void)  //扫描同步方式共有：AUTO、NORM、SIGN、NONE、SCAN 5种模式
//  391 { 
//  392   u16  i;
//  393 
//  394   switch (_Mode){ 
Synchro:
        LDR.N    R0,??DataTable11  ;; Title
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        LDR.N    R4,??DataTable12  ;; V
        MOV      R8,R0
        ADDW     R0,R8,#+576
        LDRSH    R1,[R0, #+0]
        LDRSH    R0,[R0, #+20]
        ADDW     R6,R8,#+336
        MOVS     R7,#+0
        ADDS     R1,R0,R1, LSL #+3
        LDR.N    R0,??DataTable13  ;; Wait
        MOV      R9,R0
        LDR.N    R0,??DataTable14  ;; TrackBuff
        MOV      R10,R0
        LDR.N    R0,??DataTable15  ;; Wait_Cnt
        MOV      R11,R0
        LDRSH    R0,[R6, #+80]
        CMP      R0,#+4
        BHI.N    ??Synchro_1
        TBB      [PC, R0]
        DATA
??Synchro_0:
        DC8      +3,+29,+56,+64
        DC8      +64,+0
        THUMB
//  395   case AUTO:
//  396     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_2:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  397     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_3
//  398       Process();                                  // 生成新的显示波形
??Synchro_4:
        BL       Process
//  399       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
        B.N      ??Synchro_1
//  400     } else if(Wait_Cnt==0){
??Synchro_3:
        LDR      R0,[R11, #+0]
        CMP      R0,#+0
        BNE.N    ??Synchro_1
//  401       if(JumpCnt >= 4095)  JumpCnt = 0;         
        LDRH     R0,[R4, #+36]
        LDR.N    R1,??Synchro_5   ;; 0xfff
        CMP      R0,R1
        BCC.N    ??Synchro_4
        STRH     R7,[R4, #+36]
        B.N      ??Synchro_4
//  402       Process();   
//  403       Wait_Cnt = Wait[_T_base];
//  404     } break;
//  405   case NORM:
//  406     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_6:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  407     if(__Get(FIFO_START)!=0){
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CMP      R0,#+0
        BNE.N    ??Synchro_4
//  408       Process();                                  // 生成新的显示波形
//  409       Wait_Cnt = Wait[_T_base];
//  410     } else if(Wait_Cnt==0){
        LDR      R0,[R11, #+0]
        CBNZ     R0,??Synchro_1
//  411       for(i=0; i<4*X_SIZE; ++i)  TrackBuff[i] = 0;// 清除旧的显示波形
        MOVS     R3,#+0
??Synchro_7:
        MOV      R2,R10
        STRB     R7,[R2, R0]
        ADDS     R0,R0,#+1
        UXTH     R0,R0
        MOVS     R2,#+1200
        CMP      R0,R2
        BCC.N    ??Synchro_7
//  412       Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
        B.N      ??Synchro_1
//  413     } break;
//  414   case SIGN:
//  415     __Set(TRIGG_MODE,(_Tr_source <<3)+_Tr_kind);  // 设触发条件
??Synchro_8:
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  416     if(__Get(FIFO_START)!=0)  Process();          // 生成新的显示波形
        MOVS     R0,#+2
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_1
        B.N      ??Synchro_9
//  417     break;
//  418   case NONE:
//  419   case SCAN:
//  420     __Set(TRIGG_MODE, UNCONDITION);               // 设为无条件触发
??Synchro_10:
        MOVS     R1,#+32
        MOVS     R0,#+32
        _BLF     __Set,??__Set??rT
//  421     Process();                                    // 生成当前显示波形
??Synchro_9:
        BL       Process
//  422     break;
//  423   }
//  424   Draw_Window();                                  // 刷新屏幕波形显示区
??Synchro_1:
        _BLF     Draw_Window,??Draw_Window??rT
//  425 
//  426   if((_Status == RUN)&&(__Get(FIFO_FULL)!=0)){    // FIFO is full
        LDRSH    R0,[R6, R7]
        MOV      R5,R8
        ADDS     R5,R5,#+56
        CMP      R0,#+0
        BNE.N    ??Synchro_11
        MOVS     R0,#+3
        _BLF     __Get,??__Get??rT
        CBZ      R0,??Synchro_11
//  427     __Set(FIFO_CLR, W_PTR);                       // FIFO写指针复位
        MOVS     R1,#+1
        MOVS     R0,#+6
        _BLF     __Set,??__Set??rT
//  428     Wait_Cnt = Wait[_T_base];
        LDRSH    R0,[R6, #+100]
        LDRH     R0,[R9, R0, LSL #+1]
        STR      R0,[R11, #+0]
//  429     JumpCnt =0;
//  430     if(_Mode == SIGN){
        LDRSH    R0,[R6, #+80]
        STRH     R7,[R4, #+36]
        CMP      R0,#+2
        BNE.N    ??Synchro_12
//  431       _Status = HOLD;                             // 一帧完后，进入暂停
        MOVS     R0,#+1
        STRH     R0,[R6, #+0]
//  432       _State.Flag |= UPDAT;
        LDRB     R0,[R6, #+2]
        ORRS     R0,R0,#0x2
        STRB     R0,[R6, #+2]
        B.N      ??Synchro_11
//  433     }
//  434     if(_Mode == SCAN){
??Synchro_12:
        CMP      R0,#+4
        BNE.N    ??Synchro_11
//  435       for(i=0; i<X_SIZE; i++){                    // 重建当前轨迹基线                   
        MOVS     R0,#+0
??Synchro_13:
        LDRH     R2,[R5, #+20]
        ADDS     R1,R10,R0, LSL #+2
//  436         TrackBuff[i*4 + TRACK1] = _1_posi;
//  437         TrackBuff[i*4 + TRACK2] = _2_posi; 
//  438         TrackBuff[i*4 + TRACK3] = _3_posi; 
//  439         TrackBuff[i*4 + TRACK4] = _4_posi;
        ADDS     R0,R0,#+1
        STRB     R2,[R1, #+0]
        LDRH     R2,[R5, #+100]
        UXTH     R0,R0
        STRB     R2,[R1, #+1]
        MOV      R2,R8
        LDRH     R3,[R2, #+236]!
        ADDS     R2,R2,#+80
        STRB     R3,[R1, #+2]
        LDRH     R2,[R2, #+0]
        STRB     R2,[R1, #+3]
        MOVS     R2,#+300
        CMP      R0,R2
        BCC.N    ??Synchro_13
??Synchro_11:
        LDRSH    R1,[R5, R7]
        LDR      R2,[R4, #+104]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+80]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        LSRS     R2,R2,#+10
        MULS     R1,R2,R1
        LDR      R2,[R4, #+108]
        LSRS     R1,R1,#+12
        ADDS     R0,R0,R1
        LDRSH    R1,[R5, #+20]
        LSRS     R2,R2,#+10
        SUBS     R0,R0,R1
        LDRSH    R1,[R5, #+80]
        STRH     R0,[R4, #+18]
        ADDS     R0,R4,R1
        LDRSB    R0,[R0, #+92]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+60]
        MULS     R1,R2,R1
        LSRS     R1,R1,#+12
        ADDS     R0,R0,R1
        LDRSH    R1,[R5, #+100]
        SUBS     R0,R0,R1
        STRH     R0,[R4, #+28]
//  440       }
//  441     }
//  442   }    
//  443   A_Vdc = Ka1[_A_Range] +(Ka2[_A_Range]*(a_Avg/1024))/4096 - _1_posi;  
//  444   B_Vdc = Kb1[_B_Range] +(Kb2[_B_Range]*(b_Avg/1024))/4096 - _2_posi;  
//  445 
//  446   A_Rms = Ka1[_A_Range] +(Ka2[_A_Range]*Int_sqrt(a_Ssq/4096))/1024;
        LDR      R0,[R4, #+112]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R5, R7]
        ADDS     R2,R4,R1
        LDRSB    R2,[R2, #+80]
        ADDS     R1,R4,R1, LSL #+1
        LDRH     R1,[R1, #+40]
        MULS     R1,R0,R1
        ADDS     R0,R2,R1, LSR #+10
        STRH     R0,[R4, #+26]
//  447   B_Rms = Kb1[_B_Range] +(Kb2[_B_Range]*Int_sqrt(b_Ssq/4096))/1024;
        LDR      R0,[R4, #+116]
        LSRS     R0,R0,#+12
        _BLF     Int_sqrt,??Int_sqrt??rT
        LDRSH    R1,[R5, #+80]
        LDRB     R3,[R4, #+12]
        LDRSH    R8,[R5, #+20]
        ADDS     R2,R4,R1, LSL #+1
        LDRH     R6,[R2, #+60]
        LDR.N    R2,??Synchro_5+0x4  ;; B_Rms
        ADDS     R1,R4,R1
        LDRSB    R1,[R1, #+92]
        MULS     R0,R6,R0
        ADDS     R0,R1,R0, LSR #+10
        STRH     R0,[R2, #+0]
        LDRSH    R2,[R5, R7]
//  448 
//  449   A_Max = Ka1[_A_Range] +(Ka2[_A_Range]*a_max)/1024 - _1_posi;
//  450   B_Max = Kb1[_B_Range] +(Kb2[_B_Range]*b_max)/1024 - _2_posi;
        LDRSH    R5,[R5, #+100]
        MOV      R9,R6
        LDRB     R6,[R4, #+13]
        ADDS     R0,R4,R2, LSL #+1
        LDRH     R0,[R0, #+40]
        ADDS     R2,R4,R2
        LDRSB    R2,[R2, #+80]
        MUL      R6,R9,R6
        MULS     R3,R0,R3
        ASRS     R7,R3,#+9
        ADDS     R3,R3,R7, LSR #+22
        ASRS     R7,R6,#+9
        ASRS     R3,R3,#+10
        ADDS     R6,R6,R7, LSR #+22
//  451  
//  452   A_Min = Ka1[_A_Range] +(Ka2[_A_Range]*a_min)/1024 - _1_posi;
        LDRB     R7,[R4, #+14]
        ADDS     R3,R2,R3
        SUBS     R3,R3,R8
        STRH     R3,[R4, #+22]
        MULS     R0,R7,R0
        ASRS     R7,R0,#+9
        ASRS     R6,R6,#+10
        ADDS     R0,R0,R7, LSR #+22
        ASRS     R0,R0,#+10
        ADDS     R0,R2,R0
//  453   B_Min = Kb1[_B_Range] +(Kb2[_B_Range]*b_min)/1024 - _2_posi;
        LDRB     R2,[R4, #+15]
        ADDS     R6,R1,R6
        SUBS     R6,R6,R5
        STRH     R6,[R4, #+32]
        MUL      R2,R9,R2
        SUBS     R0,R0,R8
        STRH     R0,[R4, #+24]
        ASRS     R7,R2,#+9
//  454     
//  455   A_Vpp = A_Max - A_Min;
        SUBS     R0,R3,R0
        ADDS     R2,R2,R7, LSR #+22
        ASRS     R2,R2,#+10
        ADDS     R1,R1,R2
        SUBS     R1,R1,R5
        STRH     R1,[R4, #+34]
        STRH     R0,[R4, #+20]
//  456   B_Vpp = B_Max - B_Min;
        SUBS     R0,R6,R1
        STRH     R0,[R4, #+30]
//  457 }  
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??Synchro_5:
        DC32     0xfff
        DC32     B_Rms
        CFI EndBlock cfiBlock8

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable11:
        DC32     Title

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     V

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     Wait

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     TrackBuff

        RSEG CODE:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     Wait_Cnt

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Set??rT:
        LDR.N    R3,??Subroutine0_0  ;; __Set
        BX       R3
        DATA
??Subroutine0_0:
        DC32     __Set
        CFI EndBlock cfiBlock9

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Clear_Screen??rT:
        LDR.N    R3,??Subroutine1_0  ;; __Clear_Screen
        BX       R3
        DATA
??Subroutine1_0:
        DC32     __Clear_Screen
        CFI EndBlock cfiBlock10

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI NoFunction
        THUMB
??Delayms??rT:
        LDR.N    R3,??Subroutine2_0  ;; Delayms
        BX       R3
        DATA
??Subroutine2_0:
        DC32     Delayms
        CFI EndBlock cfiBlock11

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??Get_Ref_Wave??rT:
        LDR.N    R3,??Subroutine3_0  ;; Get_Ref_Wave
        BX       R3
        DATA
??Subroutine3_0:
        DC32     Get_Ref_Wave
        CFI EndBlock cfiBlock12

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI NoFunction
        THUMB
??rT??div32_t:
        PUSH     {R3}
        CFI CFA R13+4
        LDR.N    R3,??Subroutine4_0  ;; ??div32_t
        MOV      R12,R3
        POP      {R3}
        CFI CFA R13+0
        BX       R12
        Nop      
        DATA
??Subroutine4_0:
        DC32     ??div32_t
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Get??rT:
        LDR.N    R3,??Subroutine5_0  ;; __Get
        BX       R3
        DATA
??Subroutine5_0:
        DC32     __Get
        CFI EndBlock cfiBlock14

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        THUMB
??__Read_FIFO??rT:
        LDR.N    R3,??Subroutine6_0  ;; __Read_FIFO
        BX       R3
        DATA
??Subroutine6_0:
        DC32     __Read_FIFO
        CFI EndBlock cfiBlock15

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??Draw_Window??rT:
        LDR.N    R3,??Subroutine7_0  ;; Draw_Window
        BX       R3
        DATA
??Subroutine7_0:
        DC32     Draw_Window
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon0
        CFI NoFunction
        THUMB
??Int_sqrt??rT:
        LDR.N    R3,??Subroutine8_0  ;; Int_sqrt
        BX       R3
        DATA
??Subroutine8_0:
        DC32     Int_sqrt
        CFI EndBlock cfiBlock17

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for V>`:
        DATA
        DC8 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Ch>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_max>`:
        DC8 0
`?<Initializer for b_max>`:
        DC8 0
`?<Initializer for a_min>`:
        DC8 0
`?<Initializer for b_min>`:
        DC8 0
`?<Initializer for Interlace>`:
        DC8 0
        DC8 0
`?<Initializer for A_Vdc>`:
        DC8 0, 0
`?<Initializer for A_Vpp>`:
        DC8 0, 0
`?<Initializer for A_Max>`:
        DC8 0, 0
`?<Initializer for A_Min>`:
        DC8 0, 0
`?<Initializer for A_Rms>`:
        DC8 0, 0
`?<Initializer for B_Vdc>`:
        DC8 0, 0
`?<Initializer for B_Vpp>`:
        DC8 0, 0
`?<Initializer for B_Max>`:
        DC8 0, 0
`?<Initializer for B_Min>`:
        DC8 0, 0
`?<Initializer for JumpCnt>`:
        DC8 0, 0
`?<Initializer for n>`:
        DC8 0, 0
`?<Initializer for Ka2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Kb2>`:
        DC16 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
`?<Initializer for Ka1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for Kb1>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
`?<Initializer for a_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Avg>`:
        DC8 0, 0, 0, 0
`?<Initializer for a_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for b_Ssq>`:
        DC8 0, 0, 0, 0
`?<Initializer for Tmp>`:
        DC8 0, 0, 0, 0
`?<Initializer for X_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Full>`:
        DATA
        DC8 1

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for Ka3>`:
        DATA
        DC16 256
`?<Initializer for Kb3>`:
        DC16 256
`?<Initializer for G_Attr>`:
        DC8 0, 0, 0, 0

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for D_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 179, 39999, 50
        DC8 " 20Hz "
        DC8 0
        DC16 179, 19999, 50
        DC8 " 50Hz "
        DC8 0
        DC16 179, 7999, 50
        DC8 "!100Hz!"
        DC16 179, 3999, 50
        DC8 "!200Hz!"
        DC16 179, 1999, 50
        DC8 "!500Hz!"
        DC16 179, 799, 50
        DC8 " 1KHz "
        DC8 0
        DC16 179, 399, 50
        DC8 " 2KHz "
        DC8 0
        DC16 179, 199, 50
        DC8 " 5KHz "
        DC8 0
        DC16 17, 799, 50
        DC8 "!10KHz!"
        DC16 17, 399, 50
        DC8 "!20KHz!"
        DC16 17, 199, 50
        DC8 "!50KHz!"
        DC16 0, 1439, 50
        DC8 "100KHz"
        DC8 0
        DC16 0, 719, 50
        DC8 "200KHz"
        DC8 0
        DC16 0, 359, 50
        DC8 "500KHz"
        DC8 0
        DC16 0, 143, 50
        DC8 " 1MHz "
        DC8 0
        DC16 0, 71, 50
        DC8 " 2MHz "
        DC8 0
        DC16 0, 35, 50
        DC8 " 4MHz "
        DC8 0
        DC16 0, 17, 50
        DC8 " 6MHz "
        DC8 0
        DC16 0, 11, 50
        DC8 " 8MHz "
        DC8 0
        DC16 0, 8, 50

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?<Initializer for A_Tab>`:
        DATA
        DC8 " 10Hz "
        DC8 0
        DC16 19, 9999
        DC8 " 20Hz "
        DC8 0
        DC16 19, 4999
        DC8 " 50Hz "
        DC8 0
        DC16 19, 1999
        DC8 "!100Hz!"
        DC16 19, 999
        DC8 "!200Hz!"
        DC16 19, 499
        DC8 "!500Hz!"
        DC16 19, 199
        DC8 " 1KHz "
        DC8 0
        DC16 19, 99
        DC8 " 2KHz "
        DC8 0
        DC16 19, 49
        DC8 " 5KHz "
        DC8 0
        DC16 19, 19
        DC8 "!10KHz!"
        DC16 19, 9
        DC8 "!20KHz!"
        DC16 19, 4
`?<Initializer for SIN_DATA>`:
        DC16 0, 39, 142, 304, 521, 785, 1089, 1423, 1776, 2138, 2496, 2841
        DC16 3161, 3446, 3688, 3878, 4011, 4083, 4095, 4055, 3952, 3790, 3573
        DC16 3309, 3005, 2671, 2318, 1956, 1598, 1253, 933, 648, 406, 216, 83
        DC16 11
`?<Initializer for TRG_DATA>`:
        DC16 0, 227, 454, 682, 909, 1137, 1364, 1592, 1819, 2047, 2274, 2502
        DC16 2729, 2957, 3184, 3412, 3639, 3867, 4094, 3867, 3639, 3412, 3184
        DC16 2957, 2729, 2502, 2274, 2047, 1819, 1592, 1364, 1137, 909, 682
        DC16 454, 227
`?<Initializer for SAW_DATA>`:
        DC16 0, 117, 234, 351, 468, 585, 702, 819, 936, 1053, 1170, 1287, 1404
        DC16 1521, 1638, 1755, 1872, 1989, 2106, 2223, 2340, 2457, 2574, 2691
        DC16 2808, 2925, 3042, 3159, 3276, 3393, 3510, 3627, 3744, 3861, 3978
        DC16 4095

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_Z:
        DCD      sfe(DATA_Z) - sfb(DATA_Z), sfb(DATA_Z), sfb(DATA_Z)

        RSEG DATA_ID:CONST:SORT:NOROOT(2)
`?*?DATA_ID`:

        RSEG INITTAB:CODE:ROOT(2)
        DATA
?init?tab?DATA_I:
        DCD      sfe(DATA_I) - sfb(DATA_I), sfb(DATA_I), sfb(DATA_ID)

        END
//  458 /******************************** END OF FILE *********************************/
// 
//  2 984 bytes in segment CODE
//     56 bytes in segment DATA_C
//    765 bytes in segment DATA_I
//    765 bytes in segment DATA_ID
// 17 594 bytes in segment DATA_Z
//     24 bytes in segment INITTAB
// 
//  2 904 bytes of CODE  memory (+ 104 bytes shared)
//    821 bytes of CONST memory
// 18 359 bytes of DATA  memory
//
//Errors: none
//Warnings: none
