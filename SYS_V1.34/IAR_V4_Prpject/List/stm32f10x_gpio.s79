//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.42A/W32 EVALUATION   12/Apr/2011  14:55:42 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  thumb                                               /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  D:\Design\DS203\SFW\FWLib\src\stm32f10x_gpio.c      /
//    Command line    =  D:\Design\DS203\SFW\FWLib\src\stm32f10x_gpio.c -lA  /
//                       D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_Prpject\List\  /
//                       -o D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_Prpject\Obj /
//                       \ -s9 --no_inline --cpu_mode thumb --endian little  /
//                       --cpu cortex-M3 --stack_align 4 -e --fpu None       /
//                       --dlib_config "C:\Program Files\IAR                 /
//                       Systems\Embedded Workbench 4.0                      /
//                       Evaluation\arm\LIB\dl7mptnnl8n.h" -I                /
//                       D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_Prpject\..\..\ /
//                       FWLib\inc\ -I D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_ /
//                       Prpject\..\..\USBLib\inc\ -I                        /
//                       D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_Prpject\..\inc /
//                       lude\ -I "C:\Program Files\IAR Systems\Embedded     /
//                       Workbench 4.0 Evaluation\arm\INC\"                  /
//    List file       =  D:\Design\DS203\SFW\SYS_V1.34\IAR_V4_Prpject\List\s /
//                       tm32f10x_gpio.s79                                   /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME stm32f10x_gpio

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__thumb"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??RCC_APB2PeriphResetCmd??rT
        PUBLIC GPIO_AFIODeInit
        FUNCTION GPIO_AFIODeInit,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_DeInit
        FUNCTION GPIO_DeInit,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_EXTILineConfig
        FUNCTION GPIO_EXTILineConfig,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_EventOutputCmd
        FUNCTION GPIO_EventOutputCmd,0203H
        PUBLIC GPIO_EventOutputConfig
        FUNCTION GPIO_EventOutputConfig,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_Init
        FUNCTION GPIO_Init,0203H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC GPIO_PinLockConfig
        FUNCTION GPIO_PinLockConfig,0203H
        PUBLIC GPIO_PinRemapConfig
        FUNCTION GPIO_PinRemapConfig,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC GPIO_ReadInputData
        FUNCTION GPIO_ReadInputData,0203H
        PUBLIC GPIO_ReadInputDataBit
        FUNCTION GPIO_ReadInputDataBit,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_ReadOutputData
        FUNCTION GPIO_ReadOutputData,0203H
        PUBLIC GPIO_ReadOutputDataBit
        FUNCTION GPIO_ReadOutputDataBit,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC GPIO_ResetBits
        FUNCTION GPIO_ResetBits,0203H
        PUBLIC GPIO_SetBits
        FUNCTION GPIO_SetBits,0203H
        PUBLIC GPIO_StructInit
        FUNCTION GPIO_StructInit,0203H
        PUBLIC GPIO_Write
        FUNCTION GPIO_Write,0203H
        PUBLIC GPIO_WriteBit
        FUNCTION GPIO_WriteBit,0203H
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 Undefined
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
RCC_APB2PeriphResetCmd SYMBOL "RCC_APB2PeriphResetCmd"
??RCC_APB2PeriphResetCmd??rT SYMBOL "??rT", RCC_APB2PeriphResetCmd

        EXTERN RCC_APB2PeriphResetCmd
        FUNCTION RCC_APB2PeriphResetCmd,0202H

// D:\Design\DS203\SFW\FWLib\src\stm32f10x_gpio.c
//    1 /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
//    2 * File Name          : stm32f10x_gpio.c
//    3 * Author             : MCD Application Team
//    4 * Version            : V2.0.3
//    5 * Date               : 09/22/2008
//    6 * Description        : This file provides all the GPIO firmware functions.
//    7 ********************************************************************************
//    8 * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
//    9 * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
//   10 * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
//   11 * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
//   12 * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
//   13 * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
//   14 *******************************************************************************/
//   15 
//   16 /* Includes ------------------------------------------------------------------*/
//   17 #include "stm32f10x_gpio.h"
//   18 #include "stm32f10x_rcc.h"
//   19 
//   20 /* Private typedef -----------------------------------------------------------*/
//   21 /* Private define ------------------------------------------------------------*/
//   22 /* ------------ RCC registers bit address in the alias region ----------- */
//   23 #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
//   24 
//   25 /* --- EVENTCR Register ---*/
//   26 /* Alias word address of EVOE bit */
//   27 #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
//   28 #define EVOE_BitNumber              ((u8)0x07)
//   29 #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
//   30 
//   31 #define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
//   32 #define LSB_MASK                    ((u16)0xFFFF)
//   33 #define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
//   34 #define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
//   35 #define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
//   36 #define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
//   37 
//   38 /* Private macro -------------------------------------------------------------*/
//   39 /* Private variables ---------------------------------------------------------*/
//   40 /* Private function prototypes -----------------------------------------------*/
//   41 /* Private functions ---------------------------------------------------------*/
//   42 
//   43 /*******************************************************************************
//   44 * Function Name  : GPIO_DeInit
//   45 * Description    : Deinitializes the GPIOx peripheral registers to their default
//   46 *                  reset values.
//   47 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//   48 * Output         : None
//   49 * Return         : None
//   50 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function GPIO_DeInit
        THUMB
//   51 void GPIO_DeInit(GPIO_TypeDef* GPIOx)
//   52 {
//   53   /* Check the parameters */
//   54   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//   55   
//   56   switch (*(u32*)&GPIOx)
GPIO_DeInit:
        LDR.N    R1,??GPIO_DeInit_0  ;; 0x40010800
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_1
        LDR.N    R1,??GPIO_DeInit_0+0x4  ;; 0x40010c00
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_2
        LDR.N    R1,??GPIO_DeInit_0+0x8  ;; 0x40011000
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_3
        LDR.N    R1,??GPIO_DeInit_0+0xC  ;; 0x40011400
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_4
        LDR.N    R1,??GPIO_DeInit_0+0x10  ;; 0x40011800
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_5
        LDR.N    R1,??GPIO_DeInit_0+0x14  ;; 0x40011c00
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_6
        LDR.N    R1,??GPIO_DeInit_0+0x18  ;; 0x40012000
        CMP      R0,R1
        BEQ.N    ??GPIO_DeInit_7
        POP      {PC}
//   57   {
//   58     case GPIOA_BASE:
//   59       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
??GPIO_DeInit_1:
        MOVS     R1,#+1
        MOVS     R0,#+4
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   60       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+4
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   61       break;
//   62 
//   63     case GPIOB_BASE:
//   64       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
??GPIO_DeInit_2:
        MOVS     R1,#+1
        MOVS     R0,#+8
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   65       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+8
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   66       break;
//   67 
//   68     case GPIOC_BASE:
//   69       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
??GPIO_DeInit_3:
        MOVS     R1,#+1
        MOVS     R0,#+16
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   70       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+16
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   71       break;
//   72 
//   73     case GPIOD_BASE:
//   74       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
??GPIO_DeInit_4:
        MOVS     R1,#+1
        MOVS     R0,#+32
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   75       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+32
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   76       break;
//   77       
//   78     case GPIOE_BASE:
//   79       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
??GPIO_DeInit_5:
        MOVS     R1,#+1
        MOVS     R0,#+64
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   80       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+64
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   81       break; 
//   82 
//   83     case GPIOF_BASE:
//   84       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
??GPIO_DeInit_6:
        MOVS     R1,#+1
        MOVS     R0,#+128
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   85       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+128
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        POP      {PC}
//   86       break;
//   87 
//   88     case GPIOG_BASE:
//   89       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
??GPIO_DeInit_7:
        MOVS     R1,#+1
        LSLS     R0,R1,#+8
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   90       RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+256
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//   91       break;                       
//   92 
//   93     default:
//   94       break;
//   95   }
//   96 }
        POP      {PC}             ;; return
        Nop      
        DATA
??GPIO_DeInit_0:
        DC32     0x40010800
        DC32     0x40010c00
        DC32     0x40011000
        DC32     0x40011400
        DC32     0x40011800
        DC32     0x40011c00
        DC32     0x40012000
        CFI EndBlock cfiBlock0
//   97 
//   98 /*******************************************************************************
//   99 * Function Name  : GPIO_AFIODeInit
//  100 * Description    : Deinitializes the Alternate Functions (remap, event control
//  101 *                  and EXTI configuration) registers to their default reset
//  102 *                  values.
//  103 * Input          : None
//  104 * Output         : None
//  105 * Return         : None
//  106 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function GPIO_AFIODeInit
        THUMB
//  107 void GPIO_AFIODeInit(void)
//  108 {
GPIO_AFIODeInit:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  109   RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
        MOVS     R1,#+1
        MOVS     R0,#+1
        _BLF     RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
//  110   RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
        MOVS     R1,#+0
        MOVS     R0,#+1
        POP      {LR}             ;; Pop
        CFI ?RET R14
        CFI CFA R13+0
        _BF.W    RCC_APB2PeriphResetCmd,??RCC_APB2PeriphResetCmd??rT
        CFI EndBlock cfiBlock1
//  111 }
//  112 
//  113 /*******************************************************************************
//  114 * Function Name  : GPIO_Init
//  115 * Description    : Initializes the GPIOx peripheral according to the specified
//  116 *                  parameters in the GPIO_InitStruct.
//  117 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  118 *                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
//  119 *                    contains the configuration information for the specified GPIO
//  120 *                    peripheral.
//  121 * Output         : None
//  122 * Return         : None
//  123 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function GPIO_Init
        THUMB
//  124 void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
//  125 {
GPIO_Init:
        PUSH     {R4-R8}
        CFI R8 Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+20
//  126   u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
//  127   u32 tmpreg = 0x00, pinmask = 0x00;
//  128 
//  129   /* Check the parameters */
//  130   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  131   assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
//  132   assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
//  133   
//  134 /*---------------------------- GPIO Mode Configuration -----------------------*/
//  135   currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
        LDRB     R3,[R1, #+3]
        LSLS     R2,R3,#+28
        LSRS     R2,R2,#+28
//  136 
//  137   if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
        LSLS     R3,R3,#+27
        ITTT    MI 
//  138   { 
//  139     /* Check the parameters */
//  140     assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
//  141     /* Output mode */
//  142     currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
        MOVMI    R3,R2
        LDRBMI   R2,[R1, #+2]
        ORRMI    R2,R2,R3
//  143   }
//  144 
//  145 /*---------------------------- GPIO CRL Configuration ------------------------*/
//  146   /* Configure the eight low port pins */
//  147   if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
        LDRH     R3,[R1, #+0]
        MOV      R8,R3
        LSLS     R3,R3,#+24
        BEQ.N    ??GPIO_Init_0
//  148   {
//  149     tmpreg = GPIOx->CRL;
        LDR      R4,[R0, #+0]
//  150 
//  151     for (pinpos = 0x00; pinpos < 0x08; pinpos++)
        MOVS     R3,#+0
//  152     {
//  153       pos = ((u32)0x01) << pinpos;
??GPIO_Init_1:
        MOVS     R5,#+1
        LSLS     R5,R5,R3
//  154       /* Get the port pins position */
//  155       currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
//  156 
//  157       if (currentpin == pos)
        MOV      R7,R8
        ANDS     R7,R7,R5
        CMP      R7,R5
        BNE.N    ??GPIO_Init_2
//  158       {
//  159         pos = pinpos << 2;
        LSLS     R6,R3,#+2
//  160         /* Clear the corresponding low control register bits */
//  161         pinmask = ((u32)0x0F) << pos;
//  162         tmpreg &= ~pinmask;
//  163 
//  164         /* Write the mode configuration in the corresponding bits */
//  165         tmpreg |= (currentmode << pos);
        MOVS     R7,#+15
        LSLS     R7,R7,R6
        BICS     R4,R4,R7
        MOVS     R7,R4
        LSLS     R4,R2,R6
//  166 
//  167         /* Reset the corresponding ODR bit */
//  168         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        LDRB     R6,[R1, #+3]
        ORRS     R4,R4,R7
        CMP      R6,#+40
        BNE.N    ??GPIO_Init_3
//  169         {
//  170           GPIOx->BRR = (((u32)0x01) << pinpos);
        STR      R5,[R0, #+20]
        B.N      ??GPIO_Init_2
//  171         }
//  172         else
//  173         {
//  174           /* Set the corresponding ODR bit */
//  175           if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
??GPIO_Init_3:
        CMP      R6,#+72
        IT      EQ 
//  176           {
//  177             GPIOx->BSRR = (((u32)0x01) << pinpos);
        STREQ    R5,[R0, #+16]
//  178           }
//  179         }
//  180       }
//  181     }
??GPIO_Init_2:
        ADDS     R3,R3,#+1
        CMP      R3,#+8
        BCC.N    ??GPIO_Init_1
//  182     GPIOx->CRL = tmpreg;
        STR      R4,[R0, #+0]
//  183   }
//  184 
//  185 /*---------------------------- GPIO CRH Configuration ------------------------*/
//  186   /* Configure the eight high port pins */
//  187   if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
??GPIO_Init_0:
        MOVS     R4,#+256
        CMP      R8,R4
        BCC.N    ??GPIO_Init_4
//  188   {
//  189     tmpreg = GPIOx->CRH;
        LDR      R4,[R0, #+4]
//  190     for (pinpos = 0x00; pinpos < 0x08; pinpos++)
        MOVS     R3,#+0
//  191     {
//  192       pos = (((u32)0x01) << (pinpos + 0x08));
??GPIO_Init_5:
        MOVS     R5,#+1
        MOVS     R6,R3
        ADDS     R6,R6,#+8
        LSLS     R5,R5,R6
//  193       /* Get the port pins position */
//  194       currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
//  195       if (currentpin == pos)
        MOV      R7,R8
        ANDS     R7,R7,R5
        CMP      R7,R5
        BNE.N    ??GPIO_Init_6
//  196       {
//  197         pos = pinpos << 2;
        LSLS     R6,R3,#+2
//  198         /* Clear the corresponding high control register bits */
//  199         pinmask = ((u32)0x0F) << pos;
//  200         tmpreg &= ~pinmask;
//  201 
//  202         /* Write the mode configuration in the corresponding bits */
//  203         tmpreg |= (currentmode << pos);
        MOVS     R7,#+15
        LSLS     R7,R7,R6
        BICS     R4,R4,R7
        MOVS     R7,R4
        LSLS     R4,R2,R6
//  204 
//  205         /* Reset the corresponding ODR bit */
//  206         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        LDRB     R6,[R1, #+3]
        ORRS     R4,R4,R7
        CMP      R6,#+40
        IT      EQ 
//  207         {
//  208           GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        STREQ    R5,[R0, #+20]
//  209         }
//  210         /* Set the corresponding ODR bit */
//  211         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
        LDRB     R6,[R1, #+3]
        CMP      R6,#+72
        IT      EQ 
//  212         {
//  213           GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
        STREQ    R5,[R0, #+16]
//  214         }
//  215       }
//  216     }
??GPIO_Init_6:
        ADDS     R3,R3,#+1
        CMP      R3,#+8
        BCC.N    ??GPIO_Init_5
//  217     GPIOx->CRH = tmpreg;
        STR      R4,[R0, #+4]
//  218   }
//  219 }
??GPIO_Init_4:
        POP      {R4-R8}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock2
//  220 
//  221 /*******************************************************************************
//  222 * Function Name  : GPIO_StructInit
//  223 * Description    : Fills each GPIO_InitStruct member with its default value.
//  224 * Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
//  225 *                    which will be initialized.
//  226 * Output         : None
//  227 * Return         : None
//  228 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function GPIO_StructInit
        THUMB
//  229 void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
//  230 {
//  231   /* Reset GPIO init structure parameters values */
//  232   GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
GPIO_StructInit:
        LDR.N    R1,??GPIO_StructInit_0  ;; 0xffff
        STRH     R1,[R0, #+0]
//  233   GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
        MOVS     R1,#+2
        STRB     R1,[R0, #+2]
//  234   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
        MOVS     R1,#+4
        STRB     R1,[R0, #+3]
//  235 }
        BX       LR               ;; return
        Nop      
        DATA
??GPIO_StructInit_0:
        DC32     0xffff
        CFI EndBlock cfiBlock3
//  236 
//  237 /*******************************************************************************
//  238 * Function Name  : GPIO_ReadInputDataBit
//  239 * Description    : Reads the specified input port pin.
//  240 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  241 *                : - GPIO_Pin:  specifies the port bit to read.
//  242 *                    This parameter can be GPIO_Pin_x where x can be (0..15).
//  243 * Output         : None
//  244 * Return         : The input port pin value.
//  245 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function GPIO_ReadInputDataBit
        THUMB
//  246 u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
//  247 {
GPIO_ReadInputDataBit:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  248   u8 bitstatus = 0x00;
//  249   
//  250   /* Check the parameters */
//  251   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  252   assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
//  253   
//  254   if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
        LDR      R0,[R0, #+8]
        TST      R0,R1
        ITT     NE 
//  255   {
//  256     bitstatus = (u8)Bit_SET;
        MOVNE    R0,#+1
        POPNE    {PC}
//  257   }
//  258   else
//  259   {
//  260     bitstatus = (u8)Bit_RESET;
        MOVS     R0,#+0
//  261   }
//  262   return bitstatus;
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock4
//  263 }
//  264 
//  265 /*******************************************************************************
//  266 * Function Name  : GPIO_ReadInputData
//  267 * Description    : Reads the specified GPIO input data port.
//  268 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  269 * Output         : None
//  270 * Return         : GPIO input data port value.
//  271 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function GPIO_ReadInputData
        THUMB
//  272 u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
//  273 {
//  274   /* Check the parameters */
//  275   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  276   
//  277   return ((u16)GPIOx->IDR);
GPIO_ReadInputData:
        LDR      R0,[R0, #+8]
        UXTH     R0,R0
        BX       LR               ;; return
        CFI EndBlock cfiBlock5
//  278 }
//  279 
//  280 /*******************************************************************************
//  281 * Function Name  : GPIO_ReadOutputDataBit
//  282 * Description    : Reads the specified output data port bit.
//  283 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  284 *                : - GPIO_Pin:  specifies the port bit to read.
//  285 *                    This parameter can be GPIO_Pin_x where x can be (0..15).
//  286 * Output         : None
//  287 * Return         : The output port pin value.
//  288 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function GPIO_ReadOutputDataBit
        THUMB
//  289 u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
//  290 {
GPIO_ReadOutputDataBit:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  291   u8 bitstatus = 0x00;
//  292 
//  293   /* Check the parameters */
//  294   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  295   assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
//  296   
//  297   if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
        LDR      R0,[R0, #+12]
        TST      R0,R1
        ITT     NE 
//  298   {
//  299     bitstatus = (u8)Bit_SET;
        MOVNE    R0,#+1
        POPNE    {PC}
//  300   }
//  301   else
//  302   {
//  303     bitstatus = (u8)Bit_RESET;
        MOVS     R0,#+0
//  304   }
//  305   return bitstatus;
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock6
//  306 }
//  307 
//  308 /*******************************************************************************
//  309 * Function Name  : GPIO_ReadOutputData
//  310 * Description    : Reads the specified GPIO output data port.
//  311 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  312 * Output         : None
//  313 * Return         : GPIO output data port value.
//  314 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function GPIO_ReadOutputData
        THUMB
//  315 u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
//  316 {
//  317   /* Check the parameters */
//  318   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  319     
//  320   return ((u16)GPIOx->ODR);
GPIO_ReadOutputData:
        LDR      R0,[R0, #+12]
        UXTH     R0,R0
        BX       LR               ;; return
        CFI EndBlock cfiBlock7
//  321 }
//  322 
//  323 /*******************************************************************************
//  324 * Function Name  : GPIO_SetBits
//  325 * Description    : Sets the selected data port bits.
//  326 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  327 *                  - GPIO_Pin: specifies the port bits to be written.
//  328 *                    This parameter can be any combination of GPIO_Pin_x where 
//  329 *                    x can be (0..15).
//  330 * Output         : None
//  331 * Return         : None
//  332 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function GPIO_SetBits
        THUMB
//  333 void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
//  334 {
//  335   /* Check the parameters */
//  336   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  337   assert_param(IS_GPIO_PIN(GPIO_Pin));
//  338   
//  339   GPIOx->BSRR = GPIO_Pin;
GPIO_SetBits:
        STR      R1,[R0, #+16]
//  340 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock8
//  341 
//  342 /*******************************************************************************
//  343 * Function Name  : GPIO_ResetBits
//  344 * Description    : Clears the selected data port bits.
//  345 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  346 *                  - GPIO_Pin: specifies the port bits to be written.
//  347 *                    This parameter can be any combination of GPIO_Pin_x where 
//  348 *                    x can be (0..15).
//  349 * Output         : None
//  350 * Return         : None
//  351 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function GPIO_ResetBits
        THUMB
//  352 void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
//  353 {
//  354   /* Check the parameters */
//  355   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  356   assert_param(IS_GPIO_PIN(GPIO_Pin));
//  357   
//  358   GPIOx->BRR = GPIO_Pin;
GPIO_ResetBits:
        STR      R1,[R0, #+20]
//  359 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock9
//  360 
//  361 /*******************************************************************************
//  362 * Function Name  : GPIO_WriteBit
//  363 * Description    : Sets or clears the selected data port bit.
//  364 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  365 *                  - GPIO_Pin: specifies the port bit to be written.
//  366 *                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
//  367 *                  - BitVal: specifies the value to be written to the selected bit.
//  368 *                    This parameter can be one of the BitAction enum values:
//  369 *                       - Bit_RESET: to clear the port pin
//  370 *                       - Bit_SET: to set the port pin
//  371 * Output         : None
//  372 * Return         : None
//  373 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function GPIO_WriteBit
        THUMB
//  374 void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
//  375 {
//  376   /* Check the parameters */
//  377   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  378   assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
//  379   assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
//  380   
//  381   if (BitVal != Bit_RESET)
GPIO_WriteBit:
        CBZ      R2,??GPIO_WriteBit_0
//  382   {
//  383     GPIOx->BSRR = GPIO_Pin;
        STR      R1,[R0, #+16]
        BX       LR
//  384   }
//  385   else
//  386   {
//  387     GPIOx->BRR = GPIO_Pin;
??GPIO_WriteBit_0:
        STR      R1,[R0, #+20]
//  388   }
//  389 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock10
//  390 
//  391 /*******************************************************************************
//  392 * Function Name  : GPIO_Write
//  393 * Description    : Writes data to the specified GPIO data port.
//  394 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  395 *                  - PortVal: specifies the value to be written to the port output
//  396 *                    data register.
//  397 * Output         : None
//  398 * Return         : None
//  399 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function GPIO_Write
        THUMB
//  400 void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
//  401 {
//  402   /* Check the parameters */
//  403   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  404   
//  405   GPIOx->ODR = PortVal;
GPIO_Write:
        STR      R1,[R0, #+12]
//  406 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock11
//  407 
//  408 /*******************************************************************************
//  409 * Function Name  : GPIO_PinLockConfig
//  410 * Description    : Locks GPIO Pins configuration registers.
//  411 * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
//  412 *                  - GPIO_Pin: specifies the port bit to be written.
//  413 *                    This parameter can be any combination of GPIO_Pin_x where 
//  414 *                    x can be (0..15).
//  415 * Output         : None
//  416 * Return         : None
//  417 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function GPIO_PinLockConfig
        THUMB
//  418 void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
//  419 {
//  420   u32 tmp = 0x00010000;
//  421   
//  422   /* Check the parameters */
//  423   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
//  424   assert_param(IS_GPIO_PIN(GPIO_Pin));
//  425   
//  426   tmp |= GPIO_Pin;
GPIO_PinLockConfig:
        ORRS     R2,R1,#0x10000
//  427   /* Set LCKK bit */
//  428   GPIOx->LCKR = tmp;
        STR      R2,[R0, #+24]
//  429   /* Reset LCKK bit */
//  430   GPIOx->LCKR =  GPIO_Pin;
        STR      R1,[R0, #+24]
//  431   /* Set LCKK bit */
//  432   GPIOx->LCKR = tmp;
        STR      R2,[R0, #+24]
//  433   /* Read LCKK bit*/
//  434   tmp = GPIOx->LCKR;
        LDR      R1,[R0, #+24]
//  435   /* Read LCKK bit*/
//  436   tmp = GPIOx->LCKR;
        LDR      R0,[R0, #+24]
//  437 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock12
//  438 
//  439 /*******************************************************************************
//  440 * Function Name  : GPIO_EventOutputConfig
//  441 * Description    : Selects the GPIO pin used as Event output.
//  442 * Input          : - GPIO_PortSource: selects the GPIO port to be used as source
//  443 *                    for Event output.
//  444 *                    This parameter can be GPIO_PortSourceGPIOx where x can be
//  445 *                    (A..E).
//  446 *                  - GPIO_PinSource: specifies the pin for the Event output.
//  447 *                    This parameter can be GPIO_PinSourcex where x can be (0..15).
//  448 * Output         : None
//  449 * Return         : None
//  450 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function GPIO_EventOutputConfig
        THUMB
//  451 void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
//  452 {
//  453   u32 tmpreg = 0x00;
//  454 
//  455   /* Check the parameters */
//  456   assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
//  457   assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
//  458     
//  459   tmpreg = AFIO->EVCR;
GPIO_EventOutputConfig:
        LDR.N    R2,??GPIO_EventOutputConfig_0  ;; 0x40010000
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
//  460   /* Clear the PORT[6:4] and PIN[3:0] bits */
//  461   tmpreg &= EVCR_PORTPINCONFIG_MASK;
//  462   tmpreg |= (u32)GPIO_PortSource << 0x04;
//  463   tmpreg |= GPIO_PinSource;
//  464 
//  465   AFIO->EVCR = tmpreg;
        LDR.N    R4,??GPIO_EventOutputConfig_0+0x4  ;; 0xff80
        LDR      R3,[R2, #+0]
        ANDS     R4,R4,R3
        ORRS     R0,R4,R0, LSL #+4
        ORRS     R1,R1,R0
        STR      R1,[R2, #+0]
//  466 }
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??GPIO_EventOutputConfig_0:
        DC32     0x40010000
        DC32     0xff80
        CFI EndBlock cfiBlock13
//  467 
//  468 /*******************************************************************************
//  469 * Function Name  : GPIO_EventOutputCmd
//  470 * Description    : Enables or disables the Event Output.
//  471 * Input          : - NewState: new state of the Event output.
//  472 *                    This parameter can be: ENABLE or DISABLE.
//  473 * Output         : None
//  474 * Return         : None
//  475 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function GPIO_EventOutputCmd
        THUMB
//  476 void GPIO_EventOutputCmd(FunctionalState NewState)
//  477 {
//  478   /* Check the parameters */
//  479   assert_param(IS_FUNCTIONAL_STATE(NewState));
//  480   
//  481   *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
GPIO_EventOutputCmd:
        LDR.N    R1,??GPIO_EventOutputCmd_0  ;; 0x4220001c
        STR      R0,[R1, #+0]
//  482 }
        BX       LR               ;; return
        Nop      
        DATA
??GPIO_EventOutputCmd_0:
        DC32     0x4220001c
        CFI EndBlock cfiBlock14
//  483 
//  484 /*******************************************************************************
//  485 * Function Name  : GPIO_PinRemapConfig
//  486 * Description    : Changes the mapping of the specified pin.
//  487 * Input          : - GPIO_Remap: selects the pin to remap.
//  488 *                    This parameter can be one of the following values:
//  489 *                       - GPIO_Remap_SPI1
//  490 *                       - GPIO_Remap_I2C1
//  491 *                       - GPIO_Remap_USART1
//  492 *                       - GPIO_Remap_USART2
//  493 *                       - GPIO_PartialRemap_USART3
//  494 *                       - GPIO_FullRemap_USART3
//  495 *                       - GPIO_PartialRemap_TIM1
//  496 *                       - GPIO_FullRemap_TIM1
//  497 *                       - GPIO_PartialRemap1_TIM2
//  498 *                       - GPIO_PartialRemap2_TIM2
//  499 *                       - GPIO_FullRemap_TIM2
//  500 *                       - GPIO_PartialRemap_TIM3
//  501 *                       - GPIO_FullRemap_TIM3
//  502 *                       - GPIO_Remap_TIM4
//  503 *                       - GPIO_Remap1_CAN
//  504 *                       - GPIO_Remap2_CAN
//  505 *                       - GPIO_Remap_PD01
//  506 *                       - GPIO_Remap_TIM5CH4_LSI
//  507 *                       - GPIO_Remap_ADC1_ETRGINJ
//  508 *                       - GPIO_Remap_ADC1_ETRGREG
//  509 *                       - GPIO_Remap_ADC2_ETRGINJ
//  510 *                       - GPIO_Remap_ADC2_ETRGREG
//  511 *                       - GPIO_Remap_SWJ_NoJTRST
//  512 *                       - GPIO_Remap_SWJ_JTAGDisable
//  513 *                       - GPIO_Remap_SWJ_Disable
//  514 *                  - NewState: new state of the port pin remapping.
//  515 *                    This parameter can be: ENABLE or DISABLE.
//  516 * Output         : None
//  517 * Return         : None
//  518 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon0
        CFI Function GPIO_PinRemapConfig
        THUMB
//  519 void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
//  520 {
//  521   u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
//  522 
//  523   /* Check the parameters */
//  524   assert_param(IS_GPIO_REMAP(GPIO_Remap));
//  525   assert_param(IS_FUNCTIONAL_STATE(NewState));  
//  526   
//  527   tmpreg = AFIO->MAPR;
GPIO_PinRemapConfig:
        LDR.N    R2,??GPIO_PinRemapConfig_0  ;; 0x40010004
        PUSH     {R4-R6}
        CFI R6 Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  528 
//  529   tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
        ANDS     R4,R0,#0xF0000
        LDR      R3,[R2, #+0]
        LSRS     R5,R4,#+16
//  530   tmp = GPIO_Remap & LSB_MASK;
        UXTH     R4,R0
//  531 
//  532   if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
        ANDS     R6,R0,#0x300000
        CMP      R6,#+3145728
        BNE.N    ??GPIO_PinRemapConfig_1
//  533   {
//  534     tmpreg &= DBGAFR_SWJCFG_MASK;
//  535     AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
        LDR      R6,[R2, #+0]
        MVNS     R5,#+251658240
        ANDS     R3,R3,R5
        ANDS     R5,R5,R6
        STR      R5,[R2, #+0]
        B.N      ??GPIO_PinRemapConfig_2
//  536   }
//  537   else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
??GPIO_PinRemapConfig_1:
        LSLS     R6,R0,#+11
        BPL.N    ??GPIO_PinRemapConfig_3
//  538   {
//  539     tmp1 = ((u32)0x03) << tmpmask;
//  540     tmpreg &= ~tmp1;
//  541     tmpreg |= ~DBGAFR_SWJCFG_MASK;
        MOVS     R6,#+3
        LSLS     R6,R6,R5
        BICS     R3,R3,R6
        ORRS     R3,R3,#0xF000000
        B.N      ??GPIO_PinRemapConfig_2
//  542   }
//  543   else
//  544   {
//  545     tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
//  546     tmpreg |= ~DBGAFR_SWJCFG_MASK;
??GPIO_PinRemapConfig_3:
        LSRS     R5,R0,#+21
        LSLS     R5,R5,#+4
        LSLS     R5,R4,R5
        BICS     R3,R3,R5
        ORRS     R3,R3,#0xF000000
//  547   }
//  548 
//  549   if (NewState != DISABLE)
??GPIO_PinRemapConfig_2:
        CBZ      R1,??GPIO_PinRemapConfig_4
//  550   {
//  551     tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
        MOVS     R1,R3
        MOVS     R3,R4
        LSRS     R0,R0,#+21
        LSLS     R0,R0,#+4
        LSLS     R3,R3,R0
        ORRS     R3,R3,R1
//  552   }
//  553 
//  554   AFIO->MAPR = tmpreg;
??GPIO_PinRemapConfig_4:
        STR      R3,[R2, #+0]
//  555 }
        POP      {R4-R6}
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??GPIO_PinRemapConfig_0:
        DC32     0x40010004
        CFI EndBlock cfiBlock15
//  556 
//  557 /*******************************************************************************
//  558 * Function Name  : GPIO_EXTILineConfig
//  559 * Description    : Selects the GPIO pin used as EXTI Line.
//  560 * Input          : - GPIO_PortSource: selects the GPIO port to be used as
//  561 *                    source for EXTI lines.
//  562 *                    This parameter can be GPIO_PortSourceGPIOx where x can be
//  563 *                    (A..G).
//  564 *                  - GPIO_PinSource: specifies the EXTI line to be configured.
//  565 *                   This parameter can be GPIO_PinSourcex where x can be (0..15).
//  566 * Output         : None
//  567 * Return         : None
//  568 *******************************************************************************/

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function GPIO_EXTILineConfig
        THUMB
//  569 void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
//  570 {
GPIO_EXTILineConfig:
        LDR.N    R3,??GPIO_EXTILineConfig_0  ;; 0x40010008
        ASRS     R2,R1,#+2
        PUSH     {R4}
        CFI R4 Frame(CFA, -4)
        CFI CFA R13+4
        ADDS     R2,R3,R2, LSL #+2
        LDR      R3,[R2, #+0]
        LSLS     R1,R1,#+30
        LSRS     R1,R1,#+28
        MOVS     R4,#+15
        LSLS     R4,R4,R1
        BICS     R3,R3,R4
        STR      R3,[R2, #+0]
//  571   u32 tmp = 0x00;
//  572 
//  573   /* Check the parameters */
//  574   assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
//  575   assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
//  576   
//  577   tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
//  578 
//  579   AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
//  580   AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
        LDR      R3,[R2, #+0]
        LSLS     R0,R0,R1
        ORRS     R0,R0,R3
        STR      R0,[R2, #+0]
//  581 }
        POP      {R4}
        CFI R4 SameValue
        CFI CFA R13+0
        BX       LR               ;; return
        DATA
??GPIO_EXTILineConfig_0:
        DC32     0x40010008
        CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon0
        CFI NoFunction
        THUMB
??RCC_APB2PeriphResetCmd??rT:
        LDR.N    R3,??Subroutine0_0  ;; RCC_APB2PeriphResetCmd
        BX       R3
        DATA
??Subroutine0_0:
        DC32     RCC_APB2PeriphResetCmd
        CFI EndBlock cfiBlock17

        END
//  582 
//  583 /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
// 
// 670 bytes in segment CODE
// 
// 662 bytes of CODE memory (+ 8 bytes shared)
//
//Errors: none
//Warnings: none
